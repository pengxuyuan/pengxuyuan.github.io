<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>彭序猿</title>
    <description>你好，我是彭序猿，目前在iOS开发的道路上探索，这里会写点关于iOS开发blog，还有一些生活上的琐碎事儿。</description>
    <link>http://pengxuyuan.github.io/</link>
    <atom:link href="http://pengxuyuan.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 26 Apr 2017 00:00:37 +0800</pubDate>
    <lastBuildDate>Wed, 26 Apr 2017 00:00:37 +0800</lastBuildDate>
    <generator>Jekyll v3.1.1</generator>
    
      <item>
        <title>Effective Objective-C 2.0 总结（一）</title>
        <description>&lt;h2&gt;熟悉Objective-C&lt;/h2&gt;

&lt;h3&gt;前言&lt;/h3&gt;

&lt;p&gt;最经买了本&lt;a href=&quot;http://item.jd.com/11779514.html&quot;&gt;编写高质量代码 改善Objective-C程序的61个建议&lt;/a&gt;，拿到手看了下目录感觉内容比这本52个有效方法更深点，之前的这本也是浅浅的看过，具体讲什么也不是很记得了，所以打算先重新看下这本52个有效方法，然后再来拜读新入手的这本。&lt;/p&gt;

&lt;p&gt;这里准备记录下&lt;a href=&quot;http://item.jd.com/11402853.html&quot;&gt;Effective Objective-C 2.0 编写高质量iOS与OS X 代码的52个有效方法&lt;/a&gt;这本提到的知识点。&lt;/p&gt;

&lt;h3&gt;第 1 条：了解Objective-C 语言的起源&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Objective-C 在C 语言基础上添加了面向对象特性。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;关于面向过程、面向对象的区别大概是：面向对象是将事物高度抽象化， 面向过程是一种自顶向下的编程。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。 &lt;/p&gt;

&lt;p&gt;面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。 &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个问题没有固定的答案，每个人回答的思路都是不一样的，这里可以看下逼乎上面的回答。（PS：是在下经验尚浅，不知如何回答）&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/27468564?sort=created&quot;&gt;“面向对象&amp;quot;和&amp;quot;面向过程&amp;quot;到底有什么区别？&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用消息结构的语言，其运行时所应执行的代码由运行环境来决定；而使用函数调用的语言，则由编译器决定。（Objective-C 利用运行时系统（Runtime ）来做到消息传递，也叫做动态绑定 ）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Objective-C 的重要工作都由 “运行期组件”（runtime component）而非编译器来完成，运行期组件本质上就是一种与开发者所编代码相链接的 “动态库”（dynamic libary），其代码能把开发者编写的所有程序粘合起来。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;关于静态库跟动态库的区别在于：静态库在编译的时候直接拷贝一份到应用程序的，会使得程序变大；动态库是在运行的时候加载到内存，程序会链接到动态库，不会使得程序变大，动态库相当于共享库，多个应用程序之间可以共享。&lt;/p&gt;

&lt;p&gt;关于静态库、动态库的知识点以及制作：&lt;a href=&quot;http://blog.csdn.net/liangliang2727/article/details/52941394&quot;&gt;iOS 静态库和动态库的基本介绍和使用&lt;/a&gt;、&lt;a href=&quot;http://www.cnblogs.com/Jenaral/p/5530383.html&quot;&gt;iOS 静态库，动态库与 Framework 浅析&lt;/a&gt;、&lt;a href=&quot;https://www.valiantcat.cn/index.php/2017/04/24/45.html&quot;&gt;组件化-动态库实战&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Objective-C 是C 的 “超集”，所以C 语言中的所有功能在编写Objective-C 代码时依然适用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;超集的意思大概就像爸爸跟儿子的区别：S1 就是 S2 的超集，S2 有的 S1 都有。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xnp79.com1.z0.glb.clouddn.com/64380cd7912397dd663433635f82b2b7d0a2870c.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;C 语言的内存模型（memory medel ），对象所占的内存总是分配在 “堆空间”（heap space）中，而绝不会分配在 “栈”（stack）上，不能在栈上面分配Objective-C 对象。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;分配在堆中的内存必须直接管理，而分配在栈上用于保存变量的内存则会在其栈帧弹出时自动清理，Objective-C 将堆内存管理抽象出来了，不需要用malloc 及free 来分配或释放对象所占内存，Objective-C 运行期环境把这部分工作抽象成一套内存管理架构，叫 ”引用计数“ 。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/anyaas/article/details/17099377&quot;&gt;C语言内存模型及运行时内存布局&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对于创建结构体相比，创建对象需要额外的开销，例如分配及释放堆内存等操作，所以Objective-C 对于 ”非对象类型“ 通常都是适用结构体来存储，储存在栈空间。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Objective-C 为C 语言添加了面向对象特性，是其超集。Objective-C 使用动态绑定的消息结构，也就是说，在运行时才会检查对象类型。接收一条消息之后，究竟应执行何种代码，由运行期环境而非编译器来决定。&lt;/li&gt;
&lt;li&gt;理解C 语言的核心概念有助于写好Objective-C 程序。尤其要掌握内存模型与指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 2 条：在类的头文件中尽量少引用其他头文件&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Objective-C  标准编写类方式也是头文件、实现文件组成&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;场景：A 类的头文件中有一个B 类型的属性&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   @property (nonatomic,strong) B *b;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;要通过编译，处理方式有3种：使用#import  #incudule  @class关键字&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用#import #include 这个时候可以解决问题，但不够优雅，这里就要知道B 类的具体细节，这里会引用到B 类的具体实现，会增加编译时间&lt;/li&gt;
&lt;li&gt;使用@class关键字，@class关键字 “向前声明” 告诉你有这个类，具体定义不清楚，这里就不依赖B 类的信息，这里从另外一个角度来看，可以减少A、B 之间的耦合&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;两个类互相引用的问题： A 类中有B 类的属性，B 类中也有A 类的属性&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;首先说明 #import 是由gcc 编译器支持的，其实就是 #incudule 改良版本；#import 确保了引用的这个文件只被引进一次，而#incudule 就会出现死循环引用，导致程序报错；&lt;/li&gt;
&lt;li&gt;这里使用 #import、#incudule 都不能解决这个循环问题，这里只能使用@class 来破解&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;所以应该将引入头文件的时机尽量延后，只有确有需要的时候才引用，这样子可以减少类的使用者所需引用的头文件数量。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用@class 可以减少.h中对其他类的依赖、减少链接到其他类所需要的时间，从而降低编译时间。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一般来说在.h中，首选@class 然后在迫不得已的时候才用#import (继承，实现协议)，对于协议来说 可以使用类扩展，在.m中声明一个匿名类别来声明，只有在子类需要统一实现这个协议的时候才会放在.h中，暂时没有了解到其他情况得非在.h中#import协议。&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;除非确有必要，否则不要引入头文件。一般来说，应在某个类的头文件中使用向前声明来提及别的类，并在实现文件中引入那些类的头文件。这样子可以尽量降低类之间的耦合（coupling）。&lt;/li&gt;
&lt;li&gt;有时无法使用向前声明，比如要声明某个类遵循一项协议。这种情况下，尽量把 “该类遵循某协议” 的这样声明移至 “class-continuation 分类中” 中。如果不行的话，就把协议单独放在一个头文件，然后将其引入。&lt;/li&gt;
&lt;li&gt;“class-continuation 分类”，其实就是一个特殊的分类，写在实现文件中的分类，只能被该实现文件所引用&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 3 条：多用字面量语法，少用与之等价的方法&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用字面量语法可以缩减源代码长度，使其更加易读，减少代码出错机率。字面量语法实际是一种 “语法糖”，也称 “糖衣语法”，是指计算机语言中与另外一套语法等效但是开发者用起来却更加方便的语法。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;字面数值&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   NSNumber *someNumner = @1;
   NSNumber *intNumner = @1;
   NSNumber *floatNumner = @2.5f;
   NSNumber *doubleNumner = @3.14159;
   NSNumber *charNumner = @&amp;#39;s&amp;#39;;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;字面量数组&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   NSArray *array = @[@&amp;quot;a&amp;quot;,@&amp;quot;b&amp;quot;@&amp;quot;c&amp;quot;];
   NSString *string = array[0];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;字面量字典&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   NSDictionary *dict = @{@&amp;quot;key&amp;quot;:@&amp;quot;value&amp;quot;};
   NSString *string = dict[@&amp;quot;key&amp;quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;可变数组与字典&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   NSMutableArray *mutable = [@[@&amp;quot;a&amp;quot;,@&amp;quot;b&amp;quot;] mutableCopt];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;局限性&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;字面量所创建的对象必须属于Foundation 框架，如果自定义这些类的子类，则无法用字面量语法创建其对象。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;字符串字面量创建的是常量，对象不在持有了也不会立马被释放&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   例子：

   __strong NSObject *yourObject= [NSObject new];
   __weak NSObject *myObject = yourObject;
   yourObject = nil;
   __unsafe_unretained NSObject *theirObject = myObject;
   NSLog(@&amp;quot;%p %@&amp;quot;, yourObject, yourObject);
   NSLog(@&amp;quot;%p %@&amp;quot;, myObject, myObject);
   NSLog(@&amp;quot;%p %@&amp;quot;, theirObject, theirObject);

   2017-02-16 11:02:37.702543 TKApp[1767:599122] 0x0 (null)
   2017-02-16 11:02:38.612380 TKApp[1767:599122] 0x0 (null)
   2017-02-16 11:02:40.985613 TKApp[1767:599122] 0x0 (null)


   __strong NSString *yourString = @&amp;quot;Your String&amp;quot;; 
   __weak NSString *myString = yourString;
   yourString = nil;
   __unsafe_unretained NSString *theirString = myString;
   NSLog(@&amp;quot;%p %@&amp;quot;, yourString, yourString);
   NSLog(@&amp;quot;%p %@&amp;quot;, myString, myString);
   NSLog(@&amp;quot;%p %@&amp;quot;, theirString, theirString);

   2017-02-16 11:00:42.407410 TKApp[1757:597837] 0x0 (null)
   2017-02-16 11:00:44.340836 TKApp[1757:597837] 0x1013b9480 Your String
   2017-02-16 11:00:45.392346 TKApp[1757:597837] 0x1013b9480 Your String

   这里主要有2个知识点：
   1.关于ARC中的引用计数问题
   2.字符串常量和字符串字面量的区别是什么？

   Line By Line
   第一种情况：
   __strong NSObject *yourObject = [NSObject new];
   yourObject New了一个NSObject对象 并且持有 对象引用计数＋1

   __weak NSObject *myObject = yourObject;
   myObject 指向 yourObject指向的的对象地址 没有持有 对象引用计数 不变

   yourObject = nil;
   yourObject 指向nil 不持有NSObject对象 对象不被持用 引用计数－1 这个时候这个对象自动释放

   __unsafe_unretained NSObject *theirObject = myObject;
   这个时候myObject已经被置为nil了 所以theirObject也为nil

   第二种情况：
   本来第二种情况也应该类似像第一种，这里就是关于字符串常量和字符串字面量的区别了。

   What&amp;#39;s the difference between a string constant and a string literal?

   在这里为什么没有释放的情况跟字符串常量没什么联系，主要是这里是一个字符串字面量，字符串字面值创建了不会再修改了，一个对象持有这个字符串，当它不指向它了，也不会立马释放。
   这里还有个点，Objective-C 会做字符串的编译单元，而且会合并相同字符串的编译单元，来减少额外的消耗去链接这些编译单元。

   NSString *string1 = @“pengxuyuan”;
   NSString *string2 = @“pengxuyuan”;

   string1跟string2内存地址是一样的。
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;参考资料：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/25746/whats-the-difference-between-a-string-constant-and-a-string-literal&quot;&gt;What&amp;#39;s the difference between a string constant and a string literal?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/10922888/weak-nsstring-variable-is-not-nil-after-setting-the-only-strong-reference-to-nil&quot;&gt;Weak NSString variable is not nil after setting the only strong reference to nil&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;应该使用字面量语法来创建字符串、数值、数组、字典。与创建此类对象的常规方法相比，这么做更加简明扼要。&lt;/li&gt;
&lt;li&gt;应该通过取下标操作来访问数组下标或字典中的健所对应的元素。&lt;/li&gt;
&lt;li&gt;用字面量语法创建数组或字典时，若值中有nil，则会抛出异常。因此，务必确保值里不含nil。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 4 条：多用类型常量，少用#define 预处理指令&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;在编码时候多次用到一个变量（数值，字符串等），我们会进行抽取以便修改一处所有用到的地方都会生效。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们可能会使用#define 预处理指令&lt;code&gt;#define ANIMATION_DURATION 0.3&lt;/code&gt; 编译的时候会将遇到的ANIMATION_DURATION 替换成0.3，这样子可以解决问题，但是会存在一些问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;预处理指令是没有包含类型的，有可能会将一些不需替换的也替换掉，导致异常&lt;/li&gt;
&lt;li&gt;还有如果这个预处理被定义在头文件的话，引入了这个头文件的ANIMATION_DURATION 都会被替换，这是我们不希望看到的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个时候我们定义一个常量的话，就可以包含类型信息&lt;code&gt;static const NSTimerInterval kAnimationDuration = 0.3;&lt;/code&gt;  这样子在编译的过程中就可以清楚的知道要替换的类型，如果不一致会报警告，这样子也方便排查问题；常用的命名法是：若常量局限于 “编译单元”（translation-unit，也就是 “实现文件” 中），则在前面加字母k；若常量在类之外可见，则通常已类名作为前缀。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;定义常量的位置很重要。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果将&lt;code&gt;#define ANIMATION_DURATION 0.3&lt;/code&gt;  &lt;code&gt;static const NSTimerInterval kAnimationDuration = 0.3;&lt;/code&gt;  定义在头文件，引入了这个头文件都会有这个名字，而且  &lt;code&gt;static const NSTimerInterval kAnimationDuration = 0.3;&lt;/code&gt;  定义在头文件的话，等于会声明一个全局变量，这样子所有类都可以使用了，这样子我们应该用类型作为前缀。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;static 修饰符则意味该变量仅在此变量的编译单元可见。编译器每收到一个编译单元，就会输出一份 “目标文件”（object file）。在Objective-C 的语境下，”编译单元“ 通常指每个类的实现文件（.m 文件），如果声明此变量不加static，则编译器会为它创建一个 “外部符号”（external symbol），如果其他编译单元也声明同样的变量就会报错了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果用static 和 const 声明一个变量，不会创建符号，而是会像#define 预处理指令一样，将遇到的变量全部替换，但是区别在这样子有变量类型。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果要定义一个外界可见的常量变量（constant variable），可以放在 “全局符号表”（global symbol table）中，来全局使用。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   //In the header file
   extern NSString *const EOCStringConstant;

   //In the implementtation file
   NSString *const EOCStringConstant = @&amp;quot;VALUE&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;编译器会在 “数据段”（data section）为字符串分配存储空间，这里在上面C 语言的内存模型有讲，数据段通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。 &lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;不要用预处理指令定义常量。这样定义出来的常量不含类型信息，编译器只是会在编译前据此执行查找与替换操作。即使有人重新定义了常量值，编译器也不会产生警告信息，这将导致应用程序中的常量值不一致。&lt;/li&gt;
&lt;li&gt;在实现文件中使用static const 来定义 “只在编译单元内可见的常量“（translation-unitspecific constant）。由于此类常量不在全局符号表中，所以无须为其名称加前缀。&lt;/li&gt;
&lt;li&gt;在头文件中使用extern 来声明全局变量，并在相关实现文件中定义其值。这种常量要出现在全局符号表中，所以其名称应加以区隔，通常用与之相关的类型做前缀&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 5 条：用枚举表示状态、选项、状态码&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;C++ 11 标准扩充了枚举的特性，最新系统框架使用了 “强类型”（strong type）的枚举。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实现枚举所用的数据类型取决于编译器，不过其二进制位（bit）的个数必须能完全表示下枚举编号才行，一个字节含8个二进制位，所以至多能表示256中（2&lt;sup&gt;8&lt;sup&gt;个）枚举（编号为0～255）的枚举变量。&lt;/sup&gt;&lt;/sup&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;只要枚举定义得对，各选项之间就可通过 “按位或操作符”（bitwise OR operator）来组合。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用宏来定义枚举类型，这些宏具备向后兼容（backward compatibility）能力，如果目标平台编译器支持新标准，那就使用新式语法，否则改用旧式语法。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   typedef NS_ENUM(NSUInterger,EOCConnectionState) {
    EOCConnectionStateDisconnected,
    EOCConnectionStateConnecting,
    EOCConnectionStateConnected,
   };

   typedef NS_OPTINS (NSUInterger,EOCPermittedDirection) {
        EOCPermittedDirectionUp     = 1 &amp;lt;&amp;lt; 0,
       EOCPermittedDirectionDown    = 1 &amp;lt;&amp;lt; 1,
       EOCPermittedDirectionLeft    = 1 &amp;lt;&amp;lt; 2,
       EOCPermittedDirectionRight   = 1 &amp;lt;&amp;lt; 3,
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;在switch 语句中，最好不要有default 分支，这样子要做到处理所有样式，这样子在新家类型的时候，没有default 编译器会发出警告，让我们注意到。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这些值起个易懂的名字。&lt;/li&gt;
&lt;li&gt;如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，那么就将各选项值定义为2的幂，以便通过按位或操作将其组合起来。&lt;/li&gt;
&lt;li&gt;用NS_ENUM 与 NS_OPTIONS 宏来定义枚举类型，并指明其底层数据类型。这样做可以确保枚举是用开发者所选的底层数据类型实现的，而不会才用编译器所选的类型。&lt;/li&gt;
&lt;li&gt;在处理枚举类型的switch 语句中不要实现defauly 分支。这样的话，加入新枚举之后，编译器就会提示开发者：switch 语句并未处理所有枚举。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 24 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://pengxuyuan.github.io/2017/04/Effective-Objective-C-2.0-one/</link>
        <guid isPermaLink="true">http://pengxuyuan.github.io/2017/04/Effective-Objective-C-2.0-one/</guid>
        
        
      </item>
    
      <item>
        <title>iOS Security 安全白皮书（一）</title>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/pengxuyuan/quzhibo/master/iOS%20Security%20/4DACC0BE-094F-44BE-AE94-6923AACDFC39.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;iOS 安全白皮书是苹果官方提供的，里面有苹果对于安全设计的一些细节介绍，阅读可以更佳理解苹果系统的构造，虽然不能说是看了能很深的明白其设计思路，但是可以增加知识，为以后做安全方面打下基础&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;%5B**https://www.apple.com/business/docs/iOS_Security_Guide.pdf****?****from=timeline&amp;amp;isappinstalled=0**%5D(https://www.apple.com/business/docs/iOS_Security_Guide.pdf?from=timeline&amp;amp;isappinstalled=0)&quot;&gt;官方原文地址&lt;/a&gt;  这个是官方的文档，英文好的同学强烈建议看原文档，个人经验来说，看英文跟看中文完全是两种不同的体验，但是看英文会更加有趣更加深刻&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;%5B**http://www.jianshu.com/p/3a151735fa89#**%5D(http://www.jianshu.com/p/3a151735fa89#)&quot;&gt;17年白皮书翻译&lt;/a&gt;，我是看到巧神推荐才知道有iOS 安全白皮书的，以前对于白皮书的概念还是高中的练习辅导呢，那时候上网找了下有没中文文档，很遗憾没有找到，然后过了半个月这篇翻译就出来了，很快，很强，但是原文都是机翻，然后没有润色，有点难读懂，理解能力强的同学可以直接看，全文都已经翻译好了&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://pan.baidu.com/share/link?shareid=3622394083&amp;amp;uk=809426888&quot;&gt;16年白皮书&lt;/a&gt; 这个无敌，强烈建议大家去看，翻译的堪称完美，至今不知道作者是如何做到的，一句话：无敌，是真的无敌&lt;/p&gt;

&lt;p&gt;在我翻译第一章的时候找到这些优秀的资料，一开始是放弃翻译的了。后来自我反思，以前Blog 我也看了很多，但是印象一直不深，但是这次翻译完第一章給我自己的感觉挺好的，认识了很多新知识点，感觉印象很深刻，所以还是想自己慢慢的翻译下，可以慢慢成长。这次打算自己翻译17年的白皮书和阅读&lt;a href=&quot;https://pan.baidu.com/share/link?shareid=3622394083&amp;amp;uk=809426888&quot;&gt;16年白皮书&lt;/a&gt;，一起讲iOS 安全这方面的知识学习下&lt;/p&gt;

&lt;p&gt;以下是翻译&lt;/p&gt;

&lt;hr&gt;

&lt;h3&gt;Introduction&lt;/h3&gt;

&lt;h3&gt;System Security&lt;/h3&gt;

&lt;h4&gt;Secure boot chain&lt;/h4&gt;

&lt;h4&gt;System Software Authorization&lt;/h4&gt;

&lt;h4&gt;Secure Enclave&lt;/h4&gt;

&lt;h4&gt;Touch ID&lt;/h4&gt;

&lt;h3&gt;Encryption and Data Protection&lt;/h3&gt;

&lt;h4&gt;Hardware security features&lt;/h4&gt;

&lt;h4&gt;File Data Protection  Passcodes&lt;/h4&gt;

&lt;h4&gt;Data Protection classes&lt;/h4&gt;

&lt;h4&gt;Keychain Data Protection&lt;/h4&gt;

&lt;h4&gt;Access to Safari saved passwords&lt;/h4&gt;

&lt;h4&gt;Keybags&lt;/h4&gt;

&lt;h4&gt;Security certifications and programs&lt;/h4&gt;

&lt;h3&gt;App Security&lt;/h3&gt;

&lt;h4&gt;App code signing&lt;/h4&gt;

&lt;h4&gt;Runtime process security&lt;/h4&gt;

&lt;h4&gt;Extensions&lt;/h4&gt;

&lt;h4&gt;App Groups&lt;/h4&gt;

&lt;h4&gt;Data Protection in apps&lt;/h4&gt;

&lt;h4&gt;Accessories&lt;/h4&gt;

&lt;h4&gt;HomeKit&lt;/h4&gt;

&lt;h4&gt;SiriKit&lt;/h4&gt;

&lt;h4&gt;HealthKit&lt;/h4&gt;

&lt;h4&gt;ReplayKit&lt;/h4&gt;

&lt;h4&gt;Secure Notes&lt;/h4&gt;

&lt;h4&gt;Apple Watch&lt;/h4&gt;

&lt;h3&gt;Network Security&lt;/h3&gt;

&lt;h4&gt;TLS&lt;/h4&gt;

&lt;h4&gt;VPN&lt;/h4&gt;

&lt;h4&gt;Wi-Fi&lt;/h4&gt;

&lt;h4&gt;Bluetooth&lt;/h4&gt;

&lt;h4&gt;Single Sign-on&lt;/h4&gt;

&lt;h4&gt;AirDrop security&lt;/h4&gt;

&lt;h3&gt;Apple Pay&lt;/h3&gt;

&lt;h4&gt;Apple Pay components&lt;/h4&gt;

&lt;h4&gt;How Apple Pay uses the Secure Element&lt;/h4&gt;

&lt;h4&gt;How Apple Pay uses the NFC controller&lt;/h4&gt;

&lt;h4&gt;Credit, debit, and prepaid card provisioning&lt;/h4&gt;

&lt;h4&gt;Payment authorization  Transaction-specific dynamic security code&lt;/h4&gt;

&lt;h4&gt;Contactless payments with Apple Pay&lt;/h4&gt;

&lt;h4&gt;Paying with Apple Pay within apps&lt;/h4&gt;

&lt;h4&gt;Paying with Apple Pay on the web&lt;/h4&gt;

&lt;h4&gt;Rewards cards  Suspending, removing, and erasing cards&lt;/h4&gt;

&lt;h3&gt;Internet Services&lt;/h3&gt;

&lt;h4&gt;Apple ID&lt;/h4&gt;

&lt;h4&gt;iMessage&lt;/h4&gt;

&lt;h4&gt;FaceTime&lt;/h4&gt;

&lt;h4&gt;iCloud&lt;/h4&gt;

&lt;h4&gt;iCloud Keychain&lt;/h4&gt;

&lt;h4&gt;Siri&lt;/h4&gt;

&lt;h4&gt;Continuity  Safari Suggestions, Spotlight Suggestions, Lookup, #images, and News&lt;/h4&gt;

&lt;h4&gt;Widget in Non-News Countries&lt;/h4&gt;

&lt;h3&gt;Device Controls&lt;/h3&gt;

&lt;h4&gt;Passcode protection&lt;/h4&gt;

&lt;h4&gt;iOS pairing model&lt;/h4&gt;

&lt;h4&gt;Configuration enforcement&lt;/h4&gt;

&lt;h4&gt;Mobile device management (MDM)&lt;/h4&gt;

&lt;h4&gt;Shared iPad&lt;/h4&gt;

&lt;h4&gt;Apple School Manager&lt;/h4&gt;

&lt;h4&gt;Device Enrollment&lt;/h4&gt;

&lt;h4&gt;Apple Configurator 2&lt;/h4&gt;

&lt;h4&gt;Supervision&lt;/h4&gt;

&lt;h4&gt;Restrictions&lt;/h4&gt;

&lt;h4&gt;Remote Wipe&lt;/h4&gt;

&lt;h4&gt;Lost Mode&lt;/h4&gt;

&lt;h4&gt;Activation Lock&lt;/h4&gt;

&lt;h3&gt;Privacy Controls&lt;/h3&gt;

&lt;h4&gt;Location Services&lt;/h4&gt;

&lt;h4&gt;Access to personal data&lt;/h4&gt;

&lt;h4&gt;Privacy policy&lt;/h4&gt;

&lt;h3&gt;Apple Security Bounty&lt;/h3&gt;

&lt;h3&gt;Conclusion&lt;/h3&gt;

&lt;h4&gt;A commitment to security&lt;/h4&gt;

&lt;h3&gt;Glossary&lt;/h3&gt;

&lt;h3&gt;Document Revision History&lt;/h3&gt;

&lt;hr&gt;

&lt;h2&gt;Introduction&lt;/h2&gt;

&lt;p&gt;苹果设计的 iOS 平台以安全为核心。当我们着手打造最好的移动平台时，我们借鉴了几十年的经验，打造了全新的架构。我们考虑了桌面环境的安全隐患，并在 iOS 的设计中建立了新的安全方法。我们开发并纳入许多创新功能，来加强手机安全和保护整个系统。因此，iOS 在移动设备安全方面有大的飞跃&lt;/p&gt;

&lt;p&gt;每一个 iOS 设备结合软件、硬件和服务一起工作，为了是提供更加具有安全性和透明性的用户体验。iOS 不仅是保护本地的设备和它的数据，而是扩展到整个生态系统，包括用户在本地做的一切，还有在网络上的各种互联网服务&lt;/p&gt;

&lt;p&gt;iOS 和 iOS 设备提供先进的安全功能，并且它们也很容易使用。许多功能是默认启用的，因此IT 部门不需要去大量的配置。但是关键的安全功能，如设备加密是不可配置的，所以用户不会因为错误的操作而禁止设备加密。其他功能，例如指纹识别，在提高用户体验方面，可以更简单，更直观的保护设备&lt;/p&gt;

&lt;p&gt;本文档提供了如何在 iOS 平台上实现安全技术和功能的详细细节。它也将有助于开发者将 iOS 平台安全技术和功能与自己的政策和程序相结合，以满足其特定的安全需求。&lt;/p&gt;

&lt;p&gt;这个文档主要是讨论以下几个话题:&lt;br&gt;
* 系统安全：为 iPhone、iPad、iPod touch 平台集成安全的软件和硬件&lt;br&gt;
* 加密和数据保护：架构和设计来保护用户数据，在设备丢失或被盗，或未经授权的人试图使用或修改它的情况下&lt;br&gt;
* 应用程序安全：使应用程序安全运行，且不影响平台完整性&lt;br&gt;
* 网络安全：使用行业标准的网络协议，提供安全的认证和加密的数据传输&lt;br&gt;
* 苹果支付：关于安全支付的实现&lt;br&gt;
* 互联网服务：苹果为通讯，同步，和备份做的网络基础设施
* 设备控制：允许管理 iOS 设备，防止未经授权的使用，如果设备丢失或被盗可以远程清除数据。&lt;br&gt;
* 隐私控制：可以控制是否访问位置服务和用户数据。  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/pengxuyuan/quzhibo/master/0B32958D-5334-4746-A1B2-F0D005BE1EE4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h2&gt;System Security&lt;/h2&gt;

&lt;p&gt;系统安全设计，软件和硬件在所有的iOS 设备中的核心组件都是安全的，这包括启动过程、软件更新、安全区域。这种架构在iOS中是安全的核心，不会有另外一种方式让可以运行设备&lt;/p&gt;

&lt;p&gt;在iOS 设备中，硬件和软件紧密的相结合，确保系统的每一个组件都是可信任的，并且系统是作为一个有效的整体。从最初的启动到iOS 软件更新到第三方应用程序,每一个步骤进行了分析和审查,以确保硬件和软件以最佳性能结合,并且正确合理的使用资源&lt;/p&gt;

&lt;p&gt;进入设备固件升级模式 （DFU Device Firmware Upgrade）&lt;/p&gt;

&lt;p&gt;确定只有未修改的Apple 签名代码，才可以恢复设备进入DFU 模式后，将其恢复到已知的良好状态。DFU 模式可以手动的进入：首先用USB 电缆将设备连接到电脑上，然后同时按住Home 键和电源键，然后过了8秒，放开电源键继续按住Home 键 提示：当设备进入DFU 模式屏幕上是不会出现任何东西的，如果苹果Logo 出现了，就是电源键被按住的时间太久了  &lt;/p&gt;

&lt;h3&gt;Secure boot chain 安全启动链&lt;/h3&gt;

&lt;p&gt;启动过程的每一步都包含了苹果密码签名的组件，来确保完整性，并且只有信任链验证后才能进入。这包括引导装载器、内核,内核扩展,基带固件。安全启动链确保这些最底层的软件不会被篡改&lt;/p&gt;

&lt;p&gt;当启动iOS 设备，它的应用处理器会立刻执行只读存储器（ROM）中的代码，这里称之为Boot ROM。这些不可改变的代码，被称之为硬件信任根(hardware root of trust)，在芯片制造的时候就烧进去了，而且是默认信任的&lt;/p&gt;

&lt;p&gt;引导ROM 代码包含了苹果根CA 的公钥，在允许进入加载之前用来验证iBoot 引导装载器是否是苹果签名的，这个是在信任链中的第一步，来确保接下来的每一步都是苹果签名认证的，当iBoot 完成它的任务时，它会验证和运行iOS 内核。对于搭载S1，A9或则A系列处理器的设备，Boot ROM 验证一个额外的低级引导装载器（Low-Level Bootloader  LLB），依次加载和验证iBoot&lt;/p&gt;

&lt;p&gt;如果引导过程这一步无法加载或者无法验证下一步的程序，启动会被停止，这个时候设备屏幕会显示 “Connect to iTunes” ，这个就是恢复模式。如果引导Boot ROM 无法加载或则验证低级引导装载器，这个时候会进入到DFU 模式（设备固件升级模式）。对于这两种情况，必须将设备用USB 线缆连接到电脑的itunes 恢复到工厂默认设置。对于手动进入恢复模式更多信息可以查看链接：&lt;a href=&quot;&quot;&gt;https://support.apple.com/kb/HT1808&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对于蜂窝移动数据接入的设备，基带子系统也在相似的安全启动过程中，利用基带处理器来签名软件和密钥验证&lt;/p&gt;

&lt;p&gt;设备有安全区域（Secure Enclave），这个安全区域处理器也会利用一个安全启动的启动过程来确保它由苹果来独立的软件验证和签名&lt;/p&gt;

&lt;h3&gt;System Software Authorization  系统软件授权&lt;/h3&gt;

&lt;p&gt;苹果公司定期发布软件更新来解决新兴的安全问题，并且提供新功能，同时这些支持更新到所有的iOS 设备，用户在设备上接受到iOS 更新提示，可以通过iTunes 和无线来更新，并且鼓励大家快速采用最新的安全补丁&lt;/p&gt;

&lt;p&gt;上面所述的启动过程有助于确保在设备上只能安装苹果签名的代码。防止设备被降级到旧版本以致缺乏最新的安全保护，iOS 使用这一过程被称之为系统软件授权。如果降级是可能的，攻击者可以在设备安装一个旧版本的iOS 系统来利用漏洞，但是这个漏洞已经在新版本被修复了&lt;/p&gt;

&lt;p&gt;在设备上有安全区域（Secure Enclave），安全区域处理器也会利用系统软件授权来确保软件的完整性，并且防止降级设备。具体可以看接下来的安全区域章节&lt;/p&gt;

&lt;p&gt;iOS 软件更新可以使用iTunes 更新，也可以在设备上使用空中下载技术（over the air OTA）。利用iTunes 更新，会下载一份完整的iOS 系统并安装，用OTA 更新只会下载必要的组件进行更新，提高网络效率，并不会下载整个操作系统。另外，软件更新可以被缓存在macOS 服务器运行在本地网络服务，所以iOS 设备不需要访问苹果服务器获取必要的更新数据&lt;/p&gt;

&lt;p&gt;在iOS 升级过程中，iTunes 更新（或者利用设备的OTA 更新），会连接到苹果安装授权服务器，然后发送一系列的加密测量结果（cryptographic measurements ），里面有每个安装包需要更新的信息（例如：iBoot、内核、OS 映像），还有一个临时随机的不重复的（anti-replay）值，设备的唯一ID（ECID）&lt;/p&gt;

&lt;p&gt;授权服务器会检查这个加密的测量结果，查看是否允许安装，如果匹配成功，会将ECID 加到这个测量结果中并且标记这个结果。在升级过程中，服务器将一组完整的签名数据传递给设备。添加一个处理过的ECID 到请求设备，只对加密的测量结果授权和认证，服务器确保只会由苹果提供更新&lt;/p&gt;

&lt;p&gt;启动时信任链会评估验证这个签名是从苹果来的，和从磁盘中加载这个测量结果，结合设备的ECID，匹配所要更新的签名&lt;/p&gt;

&lt;p&gt;这些步骤确保为特定的设备授权，和一个设备的旧版系统的不能被复制到另外一个设备上面去，可以防止攻击者保存服务器的响应，并且利用它来篡改设备或修改系统软件&lt;/p&gt;

&lt;h3&gt;Secure Enclave 安全区域&lt;/h3&gt;

&lt;p&gt;安全区域是一个协助处理器，是在Apple S2，Apple A7 以及后面的A 系列处理器中出现的。它使用加密内存，包括硬件随机数发生器。安全区域提供了所有的数据保护密钥管理的加密操作，并且维护数据的完整性，即使内核已受到破坏。安全区域跟应用处理器通讯被隔离在一个中断驱动信箱和一个共享内存数据缓冲器中&lt;/p&gt;

&lt;p&gt;安全区域运行一个苹果定制的L4 微核，安全区域利用自己的安全启动去做一个个性化的软件更新，这里也是跟应用处理器分离的。在A9 及以后的A 系列的处理器中，芯片会安全的生成一个UID（唯一的ID）。这个UID 连苹果和系统的其他部分都不知道的&lt;/p&gt;

&lt;p&gt;当设备启动的时候，会创建一个临时密钥，并跟UID 混淆在一起，这个用来对设备内存模块中的安全区域进行加密。除了在苹果A7 处理器上，安全区域的内存也用这个临时密钥做了加密&lt;/p&gt;

&lt;p&gt;另外，数据用一个随机值和UID 混淆后加密存储在安全区域的文件系统中&lt;/p&gt;

&lt;p&gt;安全区域负责处理指纹识别传感器的指纹数据，判断指纹是否有效，然后允许访问设备或者通过用户的购买行为，处理器跟指纹识别传感器是在串行外设接口上通讯的，处理器将数据传输到安全区域但是处理器并不能读取数据内容，这个数据用指纹识别传感器跟安全区域的一个设备共享密钥来进行加密和验证，这个密钥用AES 方法来加密，两边都会提供一个随机密钥，并且用AES-CCM 来传输数据&lt;/p&gt;

&lt;h3&gt;Touch ID 指纹识别传感器&lt;/h3&gt;

&lt;p&gt;Touch ID 是指纹识别传感器系统，可以更快、更简单、更安全的解锁手机。该技术会从任何角度读取指纹数据，并随着时间的推移更多地了解用户的指纹，随着每次使用的其他重叠节点被识别，传感器继续扩展指纹图&lt;/p&gt;

&lt;p&gt;Touch ID 可以让用户使用更长、更复杂、更实用的密码，因为用户现在不用频繁地输入密码。Touch ID 克服了用密码解锁的不便，但不是通过替换它来解决，是在一定的时间和场景内可以使用 Touch ID 来安全的访问设备&lt;/p&gt;

&lt;h3&gt;Touch ID and passcodes 指纹识别传感器和密码&lt;/h3&gt;

&lt;p&gt;要使用Touch ID，用户必须要为手机设置一个解锁密码，当Touch ID 扫描并识别到一个已经注册过的指纹时，设备可以在不需要密码的情况下解锁。Touch ID 通常可以代替密码，但是在以下情况仍然需要使用密码：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;设备刚刚启动或者重启&lt;/li&gt;
&lt;li&gt;设备48小时内没有被解锁&lt;/li&gt;
&lt;li&gt;在过去的156小时（六天半天）中，密码未被用于解锁设备，Touch ID在过去4小时内未解锁设备&lt;/li&gt;
&lt;li&gt;设备已收到远程锁定命令&lt;/li&gt;
&lt;li&gt;指纹识别失败5次&lt;/li&gt;
&lt;li&gt;使用Touch ID设置或注册新手指时&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当启用Touch ID时，按下睡眠/唤醒按钮时，设备立即锁定。很多用户会设置一个解锁的宽限期，以避免每次使用该装置输入密码。使用Touch ID，设备会在每次进入睡眠状态时锁定，并在每次唤醒时都需要指纹或者输入密码&lt;/p&gt;

&lt;p&gt;Touch ID 可以最多设置5根不同的手指，随着一根手指的录入，跟别人误匹配的机率是50万分之一。在Touch ID 指纹识别失败了五次，用户才需要输入密码以获取访问权限&lt;/p&gt;

&lt;h3&gt;Other uses for Touch ID&lt;/h3&gt;

&lt;p&gt;Touch ID 也可以用于Apple Pay（苹果提供的安全支付），有关更多Touch ID 的信息，请参阅本文档的Apple Pay 部分&lt;/p&gt;

&lt;p&gt;另外，第三方应用程序可以使用系统提供的API 来让用户使用Touch ID 或密码进行身份验证。应用程序仅被通知身份验证是否成功; 它无法访问Touch ID 或与注册指纹相关联的数据&lt;/p&gt;

&lt;p&gt;Keychain 也一样可以使用Touch ID 来解锁，只有通过指纹识别或者输入密码才能被访问。应用程序开发人员还有API 来验证用户是否设置了密码，因此可以使用Touch ID对钥匙串项进行身份验证或解锁&lt;/p&gt;

&lt;p&gt;在iOS 9 及以后，开发者可以做以下一些事情：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Require that Touch ID API operations don’t fall back to an application password or the device passcode. Along with the ability to retrieve a representation of the state of enrolled fingers, this allows Touch ID to be used as a second factor in security sensitive apps.&lt;/li&gt;
&lt;li&gt;Generate and use ECC keys inside Secure Enclave. These keys can be protected byTouch ID. Operations with these keys are always done inside Secure Enclave afterSecure Enclave authorizes the use. Apps can access these keys using Keychainthrough SecKey. SecKeys are just references to the Secure Enclave keys and the  keys never leave Secure Enclave.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Touch ID 也可以直接解锁 iTunes Store、App Store、iBooks Store 的购买项目，用户从而不用输入Apple ID 的密码。当用户授权购买的时候，设备和商店之间交换认证令牌。令牌和加密随机数保存在安全区域（Security Enclave）中，这个随机数是被所有设备和iTunes Store 共享的安全区域密钥进行签名的。在iOS 10 中，Touch ID 保护安全区域中的ECC 密钥，这个密钥是用于通过认证购买的请求&lt;/p&gt;

&lt;h3&gt;Touch ID security&lt;/h3&gt;

&lt;p&gt;仅当Home按钮的电容钢环检测到手指的触摸时，指纹传感器才会起作用，这将触发高级成像阵列扫描手指并将扫描发送到安全区域&lt;/p&gt;

&lt;p&gt;光栅扫描临时存储在安全存储器内的加密存储空间中，同时被矢量化分析，然后被丢弃。这个分析是使用subdermal ridge flow angle mapping 技术，这是丢弃重建用户实际指纹所需的细节数据的有损过程。生成的结果是没有任何身份信息相关的数据，并且加密存储在安全区域，只能有安全区域访问，而且永远不会发送給苹果或者备份在iCloud、iTunes 上面&lt;/p&gt;

&lt;h3&gt;How Touch ID unlocks an iOS device&lt;/h3&gt;

&lt;p&gt;如果Touch ID关闭，设备锁定时，保留在安全区域中的Data Protection class Complete的密钥将被丢弃。在用户通过输入密码解锁设备之前，该类中的文件和钥匙串项目是无法访问的。&lt;/p&gt;

&lt;p&gt;当Touch ID 开启的时候，这个密钥不会在设备锁定的时候被丢弃。相反，这个密钥会被加到在安全区域内的Touch ID 子系统的密钥中。当用户尝试解锁设备时，如果Touch ID识别用户的指纹，则它会提供用于一个解密 Data Protection keys 的密钥，并且设备被解锁。这个解锁的过程需要Data Protection 和 Touch ID 子系统共同协作提供额外的保护&lt;/p&gt;

&lt;p&gt;如果设备重新启动，并且在48小时没有解锁或五次失败的Touch ID 识别尝试后，安全区域会丢弃Touch ID 解锁设备所需的密钥&lt;/p&gt;
</description>
        <pubDate>Mon, 24 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://pengxuyuan.github.io/2017/04/iOS-Security-translate/</link>
        <guid isPermaLink="true">http://pengxuyuan.github.io/2017/04/iOS-Security-translate/</guid>
        
        
      </item>
    
      <item>
        <title>NSTimer 知识点</title>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h3&gt;NSTimer 是什么&lt;/h3&gt;

&lt;p&gt;定时器 一般都是用来做一些周期性的任务&lt;/p&gt;

&lt;h3&gt;使用遇到什么问题&lt;/h3&gt;

&lt;p&gt;内存释放问题、定时器失效问题&lt;/p&gt;

&lt;h3&gt;为什么会出现这些问题&lt;/h3&gt;

&lt;h4&gt;内存释放问题&lt;/h4&gt;

&lt;p&gt;当定时器被加到run loop 生效的时候，run loop 会强引用这个定时器对象（retain），然后定时器又会强引用这个Target 对象，这样子就会导致这个定时器一直存在，这个Target 对象一直存在，导致一直释放不了&lt;/p&gt;

&lt;p&gt;单纯将NSTimer置为nil，是不能使定时器失效的，runloop 已经强引用这个timer 了，要使得定时器失效需要调用invalidate 方法&lt;/p&gt;

&lt;h4&gt;定时器失效问题  （场景：滑动TableView 的时候，定时器失效）&lt;/h4&gt;

&lt;p&gt;run loop 里面有很多模式，但是一个时间点只会处在一个模式下，在某个模式的时候，只会处理和调度这个模式下面的事件和资源，NSTimer 在用scheduledTimerWithTimeInterval 生成的时候是以默认模式加入到当前的run loop，然后模式是NSDefaultRunLoopMode，但是当TableView 滑动的时run loop 会切换到UITrackingRunLoopMode 这个模式，所以此时NSTimer 就会失效&lt;/p&gt;

&lt;p&gt;所以这里是：当run loop 切换到不是timer 加入run loop 时的模式时，这个定时器就会暂时失效&lt;/p&gt;

&lt;h4&gt;关于手动将timer 置为nil 的意义&lt;/h4&gt;

&lt;p&gt;一个变量，如果被 strong 修饰，和被 weak 修饰，是有一定的区别的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;strong&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;若一个变量被 strong 修饰 （临时变量或者非 property 变量默认 strong 修饰），则其为强指针指向，在被赋值的时候，会强引用赋值对象。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;weak&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;若一个变量被 weak 修饰，则其为弱指针指向，弱指针指向的对象，如果没有被外界进行强引用的话，会在初始化方法完成之后，将变量置空。&lt;/p&gt;

&lt;p&gt;在 timer 被 strong 和 weak 修饰时的区别&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果 timer 被 strong 修饰，那么 timer 会被 self 持有一次，加入 runloop 之后，会被 runloop 再持有一次，invalidate 只会解除 runloop 对 timer 的持有，self 还是会 持有 timer ，所以需要手动置为 nil ，解除 self 对 timer 的持有。&lt;/li&gt;
&lt;li&gt;如果 timer 被 weak 修饰，那么 timer 不会被 self 持有，只是 runloop 对 timer 有一次持有（==前提是外界没有持有该timer，如果外界持有了，需要外界也手动置空==），invalidate 解除了 runloop 对 timer 的持有之后，系统会自动将 timer 置空。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果我们用了懒加载，而且 timer 是weak 修饰，没有初始化过，在下面这种写法的时候，&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;[self.timer invalidate];
NSLog(@&amp;quot;%@&amp;quot;, _timer);
[self.timer fire];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;会发现，打印出来的 _timer 依然有值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;原因是&lt;/strong&gt;：因为 timer 并没有被初始化，我们在调用 &lt;code&gt;self.timer&lt;/code&gt; 的时候，会走get方法，因为我们在 get 方法里做了懒加载，就会走一遍初始化，但是我们又在初始化方法里，加进了 runloop ，runloop 强引用了 timer ，那么在 get 方法执行完之后，timer 并不会被销毁。但是，我们又调用了 invalidate ，这个操作只会解除 runloop 对 timer 的持有，引用计数 -1，却并不会立即将 timer 置为 nil ，所以在 调用打 log 和  &lt;code&gt;[self.timer fier]&lt;/code&gt; 的时候，get 方法并不会走初始化操作了，但是因为 timer 已经不被 runloop 强引用了，所以会失效。&lt;/p&gt;

&lt;h4&gt;关于调用invalidate 方式&lt;/h4&gt;

&lt;p&gt;在调用invalidate 是否需要用valid 来判断，懒加载的情况是需要的，因为会被置为nil，多次调用的时候会重新创建，但是直接会被invalidate，这里定位会比较麻烦
invalidate 这个是使定时器失效的，调用的时候不能dealloc 里面去调用，因为run loop 强引用了定时器，定时器又强引用了Target 对象，这个时候VC 是不会被释放的，自然不会走dealloc 方法&lt;/p&gt;

&lt;h4&gt;关于NSTimer 暂停开始&lt;/h4&gt;

&lt;p&gt;这里最优雅的方式就是写一个NSTimer 的分类，然后用fireDate 触发时间来处理&lt;/p&gt;

&lt;h3&gt;如何正确使用&lt;/h3&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;#pragma mark - Lazzy load
- (NSTimer *)timer {
    if (_timer == nil) {
        _timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(timerStep) userInfo:nil repeats:YES];
    }
    return _timer;
}

-(void)viewDidDisappear:(BOOL)animated {
    [super viewDidDisappear:animated];

    if ([self.timer isValid]) {
        [self.timer invalidate];
        self.timer = nil;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h3&gt;NSTimer 官方文档介绍&lt;/h3&gt;

&lt;h4&gt;NSTimer&lt;/h4&gt;

&lt;p&gt;你可以用NSTimer 这个类来创建定时器对象。定时器会等待一个时间间隔然后触发，向一个目标对象（Target）发送特定的消息。例如你可以创建一个定时器对象，发消息到window，告诉它隔一段时间就更新自己&lt;/p&gt;

&lt;h4&gt;Overview&lt;/h4&gt;

&lt;p&gt;定时器跟run loop 一起工作，要有效地使用定时器，你应该注意run loop 的运行机制 — 可以参阅NSRunLoop 和Threading Programming Guide 章节。特别注意，run loop 会对run loop 中的定时器维持强引用，所以你不需要在把这个定时器加入到run loop 后对它维持强引用&lt;/p&gt;

&lt;p&gt;定时器并不是一个实时机制；只有run loop 正在运行的模式是定时器加到run loop 的模式时候并且检查到这个定时器的触发时间是否过去，这样子定时器才会触发。（run loop 有很多种模式，但是一个时间点只会处在一个模式下，然后定时器加入到run loop 也是可以设置需要加入到run loop 什么模式下的）因为有存在各种输入源，run loop 是典型的循环运行管理，所以定时器间隔的有效分辨是在50-100毫秒量级。如果定时器要触发的时候出现了一个耗时的操作或者当前run loop 模式不是定时器加入时候的模式，这样子定时器是不会被触发的直到下次run loop 检查定时器。&lt;/p&gt;

&lt;p&gt;因此，定时器的触发的实际时间有可能是预定触发时间之后的相当长的一段时间，另请参考&lt;a href=&quot;#Timer%20Tolerance&quot;&gt;Timer Tolerance&lt;/a&gt;章节&lt;/p&gt;

&lt;p&gt;NSTimer 跟 Core Foundation的CFRunLoopTimerRef是“toll-free bridge”，有关toll-free bridging 信息请参考Toll-free Bridging 章节&lt;/p&gt;

&lt;h4&gt;Repeating Versus Non-Repeating Timers （重复与不重复定时器）&lt;/h4&gt;

&lt;p&gt;你在创建定时器可以指定是重复的还是不重复的。不重复定时器触发一次，然后会自动的使其自动失效，从而防止定时器再次触发。相比之下，重复定时器会在相同的run loop 上面触发并且重新排列&lt;/p&gt;

&lt;p&gt;重复定时器总是根据预定的触发时间自动安排，而不是根据实际的触发时间。例如，如果定时器计划在一个特定的时间点和之后的每5秒触发， 尽管实际的触发时间延迟了，预定的触发时间依然是在原始时间点的之后5秒，如果触发时间被延迟到它下一个（或者下几个）触发时间，则这个时间段定时器只会触发一次，然后定时器在触发后会重新排列，等待下一个预定的触发时间&lt;/p&gt;

&lt;h4&gt;Timer Tolerance 定时器误差&lt;/h4&gt;

&lt;p&gt;在iOS 7及更高版本以及macOS 10.9及更高版本中，你可以指定定时器的的误差。误差可以使得在定时器触发的时候系统更加灵活，可以提高系统的优化能力，从而提高功率节省和响应能力。 定时器会在预定的触发时间点和预定触发时间点加上误差时间之间触发(A&amp;lt;-&amp;gt;A+误差)。计时器不会在预定触发时间点之前触发。对于重复定时器，下一个触发时间是从原始时间点开始计算的，不会因为个别触发时间的误差来重新计算，避免时间点偏移。误差值默认是0，这就意味着不会加上误差，但是系统保留对某个定时器触发加上一个很小的误差的权利，这个时候不会考虑这个误差属性&lt;/p&gt;

&lt;p&gt;使用定时器，你最好了解一个合适的定时器误差值。一般的经验法则是将这个误差值最少设置成定时器间隔的10%，尽管是一个很小的误差值，也会对应用程序的耗电产生很大的积极影响。&lt;/p&gt;

&lt;h4&gt;Scheduling Timers in Run Loops&lt;/h4&gt;

&lt;p&gt;一个定时器对象只能在run loop 中注册一次，尽管它可以被加到run loop 中的不同的run loop模式中去，这里有3中方法创建定时器：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Use the scheduledTimerWithTimeInterval:invocation:repeats: or scheduledTimerWithTimeInterval:target : selector:userInfo:repeats: class method to create the timer and schedule it on the current run loop in the default mode.&lt;/p&gt;

&lt;p&gt;用这两个类方法创建定时器对象，会将这个定时器对象以默认run loop 模式（NSDefaultRunLoopMode）加到当前的run loop 中&lt;/p&gt;

&lt;p&gt;Use the timerWithTimeInterval:invocation:repeats: or timerWithTimeInterval`:targetselector:userInfo:repeats: class method to create the timer object without scheduling it on a run loop. (After creating it, you must add the timer to a run loop manually by calling the addTimer:forMode: method of the corresponding NSRunLoop object.)&lt;/p&gt;

&lt;p&gt;用这个两个类方法创建定时器对象，不会将这个对象加入到run loop 中，在创建对象后，你必须手动的将这个定时器对象加入到一个run loop 中，[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];&lt;/p&gt;

&lt;p&gt;Allocate the timer and initialize it using the initWithFireDate:interval:target :selector:userInfo:repeats: method. (After creating it, you must add the timer to a run loop manually by calling the addTimer:forMode: method of the corresponding NSRunLoop object.)
在创建对象后，你必须手动的将这个定时器对象加入到一个run loop 中，[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一旦添加到run loop中，定时器会在指定的时间间隔触发直到这个定时器失效（invalidate）。一个不重复的定时器在触发后立即使其自动失效。但是对于重复的定时器调用invalidate 才能使它失效。调用invalidate 这个方法会从当前的run loop 中移除这个定时器。因此你应该在创建这个定时器的线程调用这个invalidate 方法。会立即使这个定时器失效，使其不再影响这个run loop。在invalidate 方法返回前后，这个run loop 会移除这个定时器和对这个定时器的强引用。一旦失效，这个定时器对象不能被重用&lt;/p&gt;

&lt;p&gt;在重复定时器触发之后，它会安排下一次预定时间点的触发，这个时间点是上一次触发时间点间隔的整数倍，在公差范围内。如果调用选择器方法或者调用NSInvocation 花费的时间长于定时器的间隔时间，则这个定时器会安排在下一次再触发，也就是说，定时器不会尝试补偿在调用选择器方法或调用NSInvocation 过久导致错过启动时间。&lt;/p&gt;

&lt;h4&gt;Subclassing Notes&lt;/h4&gt;

&lt;p&gt;你不应该尝试去创建NSTimer 的子类  Crash&lt;/p&gt;

&lt;h4&gt;Symbols&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/pengxuyuan/quzhibo/master/NSTimer/B9E579FA-AF03-43E2-AB2C-31F7C742D5B7.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h4&gt;Relationships&lt;/h4&gt;

&lt;p&gt;Inherits From NSObject&lt;/p&gt;
</description>
        <pubDate>Fri, 21 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://pengxuyuan.github.io/2017/04/NSTimer/</link>
        <guid isPermaLink="true">http://pengxuyuan.github.io/2017/04/NSTimer/</guid>
        
        
      </item>
    
      <item>
        <title>Effective Objective-C 2.0 总结（一）</title>
        <description>&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;阅读书籍全名&lt;a href=&quot;http://item.jd.com/11402853.html&quot;&gt;Effective Objective-C 2.0 编写高质量iOS与OS X 代码的52个有效方法&lt;/a&gt;
最经买了本&lt;a href=&quot;http://item.jd.com/11779514.html&quot;&gt;编写高质量代码 改善Objective-C程序的61个建议&lt;/a&gt;，拿到手看了下目录感觉内容比这本52个有效方法更深点，之前只是浅度这本，具体讲什么也不是很记得了，所以打算先重新看下这本52个有效方法，然后再来拜读新入手的这本。&lt;/p&gt;

&lt;p&gt;这里准备记录下&lt;a href=&quot;http://item.jd.com/11402853.html&quot;&gt;Effective Objective-C 2.0 编写高质量iOS与OS X 代码的52个有效方法&lt;/a&gt;这本提到的知识点。&lt;/p&gt;

&lt;h3&gt;第一章 熟悉Objective-C&lt;/h3&gt;

&lt;h4&gt;第1条 了解Objective-C的起源&lt;/h4&gt;

&lt;p&gt;1.OC是C语音的超集，在C的基础上面添加了面向对象特征，并且是使用了消息结构并非函数调用。
超集的意思大概就是爸爸跟儿子，S1就是S2的超集；
&lt;img src=&quot;http://7xnp79.com1.z0.glb.clouddn.com/64380cd7912397dd663433635f82b2b7d0a2870c.png&quot; alt=&quot;&quot;&gt;
消息结构与函数调用的区别是：消息结构最终执行的代码块是由运行环境决定的，函数调用的代码块有编译器决定，在编译的时候已经确定好。&lt;/p&gt;

&lt;p&gt;2.面向过程与面向对象的区别
这个说实话我也不知道怎么解释 突然感觉很难回答这个问题&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。
面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;3.OC中的动态库与静态库
博客：&lt;br&gt;
&lt;a href=&quot;http://www.cnblogs.com/cmx-ios2014/p/3802618.html?utm_source=tuicool&amp;amp;utm_medium=referral&quot;&gt;http://www.cnblogs.com/cmx-ios2014/p/3802618.html?utm_source=tuicool&amp;amp;utm_medium=referral&lt;/a&gt;
&lt;a href=&quot;http://www.jianshu.com/p/42070c513104&quot;&gt;http://www.jianshu.com/p/42070c513104&lt;/a&gt;
&lt;a href=&quot;http://www.cnblogs.com/striveLD/p/5752010.html&quot;&gt;http://www.cnblogs.com/striveLD/p/5752010.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4.C语言中的内存模型&lt;br&gt;
&lt;a href=&quot;http://www.cnblogs.com/haore147/p/3921263.html&quot;&gt;http://www.cnblogs.com/haore147/p/3921263.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;5.内存中的堆空间(heap space) 栈(stack)&lt;br&gt;
分配在堆中的内存必须直接管理，分配在栈上用于保存变量的内存则会在栈帧弹出式自动清理。&lt;/p&gt;

&lt;p&gt;6.不能在栈上面分配OC对象&lt;/p&gt;

&lt;p&gt;7.CGRect不属于OC对象
相比于结构体，创建对象需要额外的开销，比如分配及释放内存堆，所以在操作一对非OC对象是，可以考虑用结构体来操作。&lt;/p&gt;

&lt;h4&gt;第2条 在类的头文件中尽量少引用其他头文件&lt;/h4&gt;

&lt;p&gt;1.A类的头文件中有一个B类型的属性&lt;br&gt;
引用头文件的方式有3种：#import #incudule @class关键字&lt;br&gt;
首先说明#import是由gcc编译器支持的，其实就是#incudule改良版本&lt;br&gt;
#import确保了引用的这个文件只被引进一次，而#incudule就会出现死循环引用，导致程序报错；&lt;br&gt;
@class关键字“向前声明”告诉你有这个类，具体定义不清楚，这样子可以解决引用无法识别该对象的问题，也解决了循环引用的问题&lt;br&gt;
#import #incudule 引进类来，会拿到这个类的头文件的信息了，这里违反了最少原则，所以一般在.h头文件中尽量少用；&lt;br&gt;
使用@class可以减少.h中对其他类的依赖、减少链接到其他类所需要的时间，从而降低编译时间；  &lt;/p&gt;

&lt;p&gt;一般来说在.h中，首选@class 然后在迫不得已的时候才用#import(继承，实现协议)&lt;br&gt;
对于协议来说 可以使用类扩展在.m中申明一个匿名类别来声明，只有在子类需要统一实现这个协议的时候才会放在.h中，暂时没有了解到其他情况得非在.h中#import协议。  &lt;/p&gt;

&lt;p&gt;2.两个类互相引用的问题 A类中有B类的属性 B类中也有A类的属性&lt;br&gt;
使用#incudule这样子会报错，但是使用#import的话只能保证一个类被编译到了，也是用问题的，在这里只能用@class解决这个循环引用的问题。  &lt;/p&gt;

&lt;p&gt;&lt;del&gt;3.在实现文件中声明此类实现了该委托协议，并把这段代码放在“class-continuation”分类中&lt;/del&gt;&lt;/p&gt;

&lt;h4&gt;第3条 多使用字面量语法，少用与之等价的方法&lt;/h4&gt;

&lt;p&gt;1.好处缩减代码长度，更加易读&lt;/p&gt;

&lt;p&gt;2.对于字面量数组/字典来说，对象中有nil会抛出异常&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;NSArray *array = @[@&amp;quot;&amp;quot;,@&amp;quot;&amp;quot;,@&amp;quot;&amp;quot;];&lt;/p&gt;

&lt;p&gt;NSDictionary *dictionary = @{key:value}；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;3.糖衣语法(语法糖)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;糖衣语法，又叫‘语法糖’、‘语法盐’等等，是由英国计算机科学家彼得·约翰·兰达（Peter J.Landin）发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;额，就是简单粗暴，减少出错；&lt;/p&gt;

&lt;p&gt;&lt;del&gt;4.字面量语法 非字面量语法&lt;/del&gt;&lt;/p&gt;

&lt;h4&gt;第4条 多用类型常量，少用#define预处理指令&lt;/h4&gt;

&lt;p&gt;1.#define预处理指令
#define kAnimationTime 3&lt;br&gt;
在程序代码中多次使用同一个变量，可以用#define预处理指令来抽取，这样子可以达到第一层的抽取，在一般情况下面我们可以满足需求，利用define它会将kAnimationTime直接替换成3；所以这里如果定义在.h文件中，在其他引用了这个头文件的类中的kAnimationTime也会被替换，而且#define预处理指令是没有类型的，替换掉了也不清楚，可以在引用的地方修改定义好的值，有一定的风险，万一实在想用，记得注意命名问题和定义的位置。  &lt;/p&gt;

&lt;p&gt;2.定义常量跟#define预处理指令的区别
static const CGFloat kMargin = 10.0f；&lt;br&gt;
可以明确的定义清楚类型，防止使用代码修改值，这样子在使用的过程减少出错。&lt;br&gt;
定义名字的常用规则：需要限定在某编译单元(即本类中)则在前面添加k；&lt;br&gt;
需要在其他类可见，一般是用此类的类名做前缀；&lt;br&gt;
使用static修饰，是将该变量仅仅定义在该变量的编译单元中，如果不使用static修饰,编译器会为这个变量创建一个&amp;quot;外部符号&amp;quot;,此时其他类也声明了同名变量就会报错了。&lt;/p&gt;

&lt;p&gt;3.全局常量，需要添加到“全局符号表中”&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;extern NSString *const PXYNotification;  &lt;/p&gt;

&lt;p&gt;NSString *const PXYNotification = @PXYNotification&amp;quot;&amp;quot;;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;del&gt;####第5条 用枚举表示状态、选项、状态码&lt;/del&gt;
&lt;del&gt;1.定义枚举的几种方式&lt;/del&gt;
&lt;del&gt;2.按位与操作符&lt;/del&gt;
&lt;del&gt;3.NS_ENUM与NS_OPTIONS宏的区别&lt;/del&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 28 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://pengxuyuan.github.io/2016/07/Effective-Objective-C-2.0-zongjie-one/</link>
        <guid isPermaLink="true">http://pengxuyuan.github.io/2016/07/Effective-Objective-C-2.0-zongjie-one/</guid>
        
        
      </item>
    
      <item>
        <title>iOS单例模式</title>
        <description>&lt;p&gt;单例 保证一个对象只实例化一次 全局使用的都是同一个对象&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一是某个类只能有一个实例；&lt;/li&gt;
&lt;li&gt;二是它必须自行创建这个实例；&lt;/li&gt;
&lt;li&gt;三是它必须自行向整个系统提供这个实例。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一种写法：
&lt;pre&gt; +(instancetype)shareInstance{&lt;br&gt;
static PXYGuidePageHelper *instance;&lt;br&gt;
        @synchronized(self) {&lt;br&gt;
            if (instance == nil) {&lt;br&gt;
                instance = [PXYGuidePageHelper new];&lt;br&gt;
            }&lt;br&gt;
        }&lt;br&gt;
    return instance;&lt;br&gt;
}&lt;br&gt;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;第二种写法：
&lt;pre&gt; +(instancetype)shareInstance{
    static dispatch_once_t onceToken;
    static PXYGuidePageHelper *instance;
    dispatch_once(&amp;amp;onceToken, &lt;sup&gt;{&lt;/sup&gt;
        instance = [PXYGuidePageHelper new];
    });
    return instance;
}
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;首先说下第一种写法：
单例实例是全局使用的，因此要要定义成全局变量 用static修饰 static介绍
@synchronized这个指令是解决多个线程同时执行同一个代码块 ，@synchronized相当于给这个代码块加锁（防止死锁）
这里判断当前对象时候存在，不存在创建，存在则返回该对象。&lt;/p&gt;

&lt;p&gt;第二种写法：
dispatch_once这个就是保证只执行一次 所以这里确保 该实例只创建一次&lt;/p&gt;

&lt;p&gt;两者区别：
第一种在每次执行shareInstance方法是都会加一次锁，然后在代码块里面判断 if (instance == nil) 这个来决定是否实例化，这里每次都会有开销。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;“实际上，如果你去看这个函数所在的头文件，你会发现目前它的实现其实是一个宏，进行了内联的初始化测试，这意味着通常情况下，你不用付出函数调用的负载代价，并且会有更少的同步控制负载。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这样子分析的GCD创建单例更加优雅点。&lt;/p&gt;

&lt;p&gt;－－－－&lt;br&gt;
第一种相当于是 懒汉式单例类 双检锁写法&lt;/p&gt;

&lt;p&gt;对于第一种的每次都要加锁的写法，可以使用双检锁写法来提高效率。
&lt;pre&gt;+(instancetype)shareInstance{
    static PXYGuidePageHelper *instance;
    if (instance == nil) {
        @synchronized(self) {
            if (instance == nil) {
                instance = [PXYGuidePageHelper new];
            }
        }
    }
    return instance;
}&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;这样子就能保证只有在第一次进行加锁开销。&lt;/p&gt;

&lt;p&gt;还有一种 饿汉式单例
是在程序一启动就实例化 +(void)load函数里面实现，然后在allocWithZone进行加锁判空操作，这样子无论你是否用特定的方法获取实例，都会返回同一个对象。&lt;/p&gt;

&lt;p&gt;以上&lt;/p&gt;
</description>
        <pubDate>Thu, 28 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://pengxuyuan.github.io/2016/07/iOS_SigleCase/</link>
        <guid isPermaLink="true">http://pengxuyuan.github.io/2016/07/iOS_SigleCase/</guid>
        
        
      </item>
    
      <item>
        <title>关于团队开发的编码规范</title>
        <description>&lt;p&gt;以下是均是个人看法，不喜勿喷，欢迎大家一起多多交流，共同进步。&lt;/p&gt;

&lt;p&gt;对于编码，每个人都有自己的习惯 ，但是我觉得要开发出优质代码的话有些规范还是要统一，毕竟你不是一个人做开发，你要考虑到团队协作以及后续人员维护你的项目，你想一下，让你维护一个别人的项目，上来就是ViewController几千行，所有页面逻辑全部在控制器里面，各种不能见名思义的变量属性，瞬间有种想死的感觉有木有😂😂😂所以吧，还是不要任性开发。&lt;/p&gt;

&lt;p&gt;说是对于团队开发的编码规范，其实在个人独立开发的时候也需要注意编码的问题，网上面有很多大神写的关于编码的blog，我就不复述了...&lt;/p&gt;

&lt;p&gt;这里我就写写最近在团队发开种遇到的问题吧，写的不全，后期遇到的其他问题都会贴上来的，一是提醒自己在编码过程中要规范，二是让大家看看我有什么地方理解错了，及时改正，三是，额，三是我写动手写点东西了，好久没写了....&lt;/p&gt;

&lt;p&gt;好了，入正题吧 不然又......&lt;/p&gt;

&lt;h5&gt;1.你要了解点MVC 最少你要知道我们还有View 跟 Model吧&lt;/h5&gt;

&lt;p&gt;哥哥，真的不要给我控制器里面写个几千行，我实在是维护不了，不要说维护了，估计在看懂你的逻辑之前我都已经挂了...&lt;/p&gt;

&lt;p&gt;现在项目开发中，最常用的就是MVC了，然后就是MVVM（我就只会这两个）有这两个开发一般般的项目我觉得够用了。控制器是拿来连接View跟Model的 扮演个协调者的角色 并不是要你把所有的逻辑写在里面。&lt;/p&gt;

&lt;h5&gt;2.我们先谈谈ViewController里面的一些东西&lt;/h5&gt;

&lt;p&gt;首先，不要把所有的属性变量放在.h文件里面。.h文件是暴露出去的，所以越简洁越好，坚持最少原则，用最少最简单的方式完成功能，你放在.h别人用的时候就可以随意操作你的暴露出去的东西了额，还有，我没搞懂为什么在.m文件里面实现的代理，声明要放在.h 比如说这个不要放在.h吧 实在是不好看，也没什么用。&lt;/p&gt;

&lt;p&gt;还有如果想更好点的话，在.h尽可能的用@class 这样子编译的压力小点 逼格也高点&lt;/p&gt;

&lt;p&gt;对于声明变量属性的话，到底是下面&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;｛
 UITableview  *tableview；
｝&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;还是&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;@property (nonatomic,strong) UITableView *tableview;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;哪个好呢，其实都还好，看个人，我比较喜欢下面那种，可以自动生成get set方法 用懒加载的时候也很是方便啊&lt;/p&gt;

&lt;p&gt;然后在使用的时候，也要注意下 不要一时用 _tableview 一时用self.tableview 一开始我是分别用的，后来看书看到，_tableview 跟self-&amp;gt;tableview 是直接访问地址的，self.tableview是通过消息机制调用get方法，所以呢，_tableview获取的比self. tableview快，所以折中的方法是，在内部读取数据时候尽量用_tableView，设置属性值时候，用self.tableview，这样子你可以通过重写set方法 更加可控 可调试点。&lt;/p&gt;

&lt;h5&gt;关于命名&lt;/h5&gt;

&lt;p&gt;额，命名这个东西老生常谈了，个人坚持的是，宁愿长也不要难认识。&lt;/p&gt;

&lt;h5&gt;函数摆放&lt;/h5&gt;

&lt;p&gt;个人有强迫症，所以比较会注意。&lt;/p&gt;

&lt;p&gt;比如生命周期函数写在一块 懒加载一块 网络请求一块 代理一块 事件一块&lt;/p&gt;

&lt;p&gt;用个#pragma mark - - 瞬间整个世界都有序了 有木有！！！&lt;/p&gt;

&lt;h5&gt;关于注释&lt;/h5&gt;

&lt;p&gt;说到这里，再说下关于注释这东西。通常说法是：程序员最讨厌别人不写注释和自己写注释。&lt;/p&gt;

&lt;p&gt;其实个人我是坚持代码即注释，就是比较讨厌注释的，觉得好的代码不需要注释。&lt;/p&gt;

&lt;p&gt;我总感觉注释很脏啊- -  总感觉多了点什么。（个人强迫症原因....）&lt;/p&gt;

&lt;p&gt;吐槽下，接手的项目全部是注释，关键是注释都没什么用啊.....&lt;/p&gt;

&lt;p&gt;生命周期函数全部写一次注释，这些不写 新生都知道是干嘛的啊- -&lt;/p&gt;

&lt;p&gt;关键是.m文件你的注释为什么要写成这样子呢？&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;/**
*
*初始化方法
*@return self
*/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;每个生命周期都是这样子，是真的烦，反正看到的我都删除了。&lt;/p&gt;

&lt;h5&gt;3.关于View&lt;/h5&gt;

&lt;p&gt;个人观点：凡事复杂点的组件（你在屏幕上看到的东西） 都自己写个view出来 不要在ViewController里面写你View里面的布局逻辑，这样子控制器本来不胖的都被你搞胖了😂😂😂&lt;/p&gt;

&lt;p&gt;额，还有，发现很多人虽然写了View 但是 但是 他把View的控件属性全部写在.h里面 然后在ViewController里面直接赋值，这样子还真没搞懂你的View到底是干嘛的 也不能只写布局啊。自己的东西自己管啊，View.h 暴露个Model，ViewController传个Model就好了啊 再不济你传个字典也比在ViewController直接赋值的好啊。&lt;/p&gt;

&lt;p&gt;最后就是：自己的事情自己做&lt;/p&gt;

&lt;p&gt;而还有，不要滥用自定义View 我最近看到一种写法是 View嵌入View然后再嵌入View再嵌入View....太恶心了&lt;/p&gt;

&lt;p&gt;更甚的是，全部写在.h中 设置属性的就是在控制器self.view.view.view.text 然后增加事件就是 self.view.view.view addTag&lt;/p&gt;

&lt;p&gt;看到这个我心中无数只草泥马啊。。。&lt;/p&gt;

&lt;p&gt;善用代理跟block 这样子代码好看还解藕了，多好。&lt;/p&gt;

&lt;p&gt;最近还看到一种用协议来创建自定义View的 是真的厉害 高内聚 代码一下子就可以看懂了 而且逼格一下子就上去了。&lt;/p&gt;

&lt;p&gt;网址：&lt;a href=&quot;http://reviewcode.cn/article.html?reviewId=5&quot;&gt;自定义UI控件&lt;/a&gt;&lt;/p&gt;

&lt;h5&gt;其他&lt;/h5&gt;

&lt;p&gt;额 说到逼格  最近学到 定义常量少用&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;#define&lt;/p&gt;

&lt;p&gt;用static const CGFloat kBorderMargin = 15;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这样子会比较好，可以预先知道类型，减少出错的机会。&lt;/p&gt;

&lt;h5&gt;4.现在的文件命名还不错，都是峰驼式的。&lt;/h5&gt;

&lt;h5&gt;5.封装思想，重用组件。&lt;/h5&gt;

&lt;p&gt;编码的时候做个懒人。&lt;/p&gt;

&lt;p&gt;不要重复的写一样的代码，还不好改。具体的，也不好写，思想大概就是多处用到的一样的东西，抽出来，不要copy代码。&lt;/p&gt;

&lt;h5&gt;The End&lt;/h5&gt;

&lt;p&gt;这篇文章就是拿来练习下markdown的，刚学。&lt;/p&gt;
</description>
        <pubDate>Mon, 13 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://pengxuyuan.github.io/2016/06/CodingStandardsForTeamDevelopment/</link>
        <guid isPermaLink="true">http://pengxuyuan.github.io/2016/06/CodingStandardsForTeamDevelopment/</guid>
        
        
      </item>
    
  </channel>
</rss>
