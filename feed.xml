<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>彭序猿</title>
    <description>你好，我是彭序猿，目前在iOS开发的道路上探索，这里会写点关于iOS开发blog，还有一些生活上的琐碎事儿。</description>
    <link>http://pengxuyuan.github.io/</link>
    <atom:link href="http://pengxuyuan.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 17 Nov 2016 01:16:07 +0800</pubDate>
    <lastBuildDate>Thu, 17 Nov 2016 01:16:07 +0800</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>Effective Objective-C 2.0 总结（一）</title>
        <description>&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;阅读书籍全名&lt;a href=&quot;http://item.jd.com/11402853.html&quot;&gt;Effective Objective-C 2.0 编写高质量iOS与OS X 代码的52个有效方法&lt;/a&gt;
最经买了本&lt;a href=&quot;http://item.jd.com/11779514.html&quot;&gt;编写高质量代码 改善Objective-C程序的61个建议&lt;/a&gt;，拿到手看了下目录感觉内容比这本52个有效方法更深点，之前只是浅度这本，具体讲什么也不是很记得了，所以打算先重新看下这本52个有效方法，然后再来拜读新入手的这本。
这里准备记录下&lt;a href=&quot;http://item.jd.com/11402853.html&quot;&gt;Effective Objective-C 2.0 编写高质量iOS与OS X 代码的52个有效方法&lt;/a&gt;这本提到的知识点。&lt;/p&gt;

&lt;h3&gt;第一章 熟悉Objective-C&lt;/h3&gt;

&lt;h4&gt;第1条 了解Objective-C的起源&lt;/h4&gt;

&lt;h5&gt;1.OC是C语音的超集，在C的基础上面添加了面向对象特征，并且是使用了消息结构并非函数调用。&lt;/h5&gt;

&lt;p&gt;超集的意思大概就是爸爸跟儿子，S1就是S2的超集；
&lt;img src=&quot;http://7xnp79.com1.z0.glb.clouddn.com/64380cd7912397dd663433635f82b2b7d0a2870c.png&quot; alt=&quot;&quot;&gt;
消息结构与函数调用的区别是：消息结构最终执行的代码块是由运行环境决定的，函数调用的代码块有编译器决定，在编译的时候已经确定好。&lt;/p&gt;

&lt;h5&gt;2.面向过程与面向对象的区别&lt;/h5&gt;

&lt;p&gt;这个说实话我也不知道怎么解释 突然感觉很难回答这个问题&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。
面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5&gt;3.OC中的动态库与静态库&lt;/h5&gt;

&lt;p&gt;博客：
&lt;a href=&quot;http://www.cnblogs.com/cmx-ios2014/p/3802618.html?utm_source=tuicool&amp;amp;utm_medium=referral&quot;&gt;http://www.cnblogs.com/cmx-ios2014/p/3802618.html?utm_source=tuicool&amp;amp;utm_medium=referral&lt;/a&gt;
&lt;a href=&quot;http://www.jianshu.com/p/42070c513104&quot;&gt;http://www.jianshu.com/p/42070c513104&lt;/a&gt;
&lt;a href=&quot;http://www.cnblogs.com/striveLD/p/5752010.html&quot;&gt;http://www.cnblogs.com/striveLD/p/5752010.html&lt;/a&gt;&lt;/p&gt;

&lt;h5&gt;4.C语言中的内存模型&lt;/h5&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/haore147/p/3921263.html&quot;&gt;http://www.cnblogs.com/haore147/p/3921263.html&lt;/a&gt;&lt;/p&gt;

&lt;h5&gt;5.内存中的堆空间(heap space) 栈(stack)&lt;/h5&gt;

&lt;p&gt;分配在堆中的内存必须直接管理，分配在栈上用于保存变量的内存则会在栈帧弹出式自动清理。&lt;/p&gt;

&lt;h5&gt;6.不能在栈上面分配OC对象&lt;/h5&gt;

&lt;h5&gt;7.CGRect不属于OC对象&lt;/h5&gt;

&lt;p&gt;相比于结构体，创建对象需要额外的开销，比如分配及释放内存堆，所以在操作一对非OC对象是，可以考虑用结构体来操作。&lt;/p&gt;

&lt;h4&gt;第2条 在类的头文件中尽量少引用其他头文件&lt;/h4&gt;

&lt;h5&gt;1.A类的头文件中有一个B类型的属性&lt;/h5&gt;

&lt;p&gt;引用头文件的方式有3种：#import #incudule @class关键字
首先说明#import是由gcc编译器支持的，其实就是#incudule改良版本
#import确保了引用的这个文件只被引进一次，而#incudule就会出现死循环引用，导致程序报错；
@class关键字“向前声明”告诉你有这个类，具体定义不清楚，这样子可以解决引用无法识别该对象的问题，也解决了循环引用的问题;
#import #incudule 引进类来，会拿到这个类的头文件的信息了，这里违反了最少原则，所以一般在.h头文件中尽量少用；
使用@class可以减少.h中对其他类的依赖、减少链接到其他类所需要的时间，从而降低编译时间；
一般来说在.h中，首选@class 然后在迫不得已的时候才用#import(继承，实现协议)
对于协议来说 可以使用类扩展在.m中申明一个匿名类别来声明，只有在子类需要统一实现这个协议的时候才会放在.h中，暂时没有了解到其他情况得非在.h中#import协议。&lt;/p&gt;

&lt;h5&gt;2.两个类互相引用的问题 A类中有B类的属性 B类中也有A类的属性&lt;/h5&gt;

&lt;p&gt;使用#incudule这样子会报错，但是使用#import的话只能保证一个类被编译到了，也是用问题的，在这里只能用@class解决这个循环引用的问题。
&lt;del&gt;###3.在实现文件中声明此类实现了该委托协议，并把这段代码放在“class-continuation”分类中&lt;/del&gt;&lt;/p&gt;

&lt;h4&gt;第3条 多使用字面量语法，少用与之等价的方法&lt;/h4&gt;

&lt;h5&gt;1.好处缩减代码长度，更加易读&lt;/h5&gt;

&lt;h5&gt;2.对于字面量数组/字典来说，对象中有nil会抛出异常&lt;/h5&gt;

&lt;p&gt;NSArray *array = @[@&amp;quot;&amp;quot;,@&amp;quot;&amp;quot;,@&amp;quot;&amp;quot;];
NSDictionary *dictionary = @{key:value}；&lt;/p&gt;

&lt;h5&gt;3.糖衣语法(语法糖)&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;糖衣语法，又叫‘语法糖’、‘语法盐’等等，是由英国计算机科学家彼得·约翰·兰达（Peter J.Landin）发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;额，就是简单粗暴，减少出错；&lt;/p&gt;

&lt;p&gt;&lt;del&gt;#####4.字面量语法 非字面量语法&lt;/del&gt;&lt;/p&gt;

&lt;h4&gt;第4条 多用类型常量，少用#define预处理指令&lt;/h4&gt;

&lt;h5&gt;1.#define预处理指令&lt;/h5&gt;

&lt;p&gt;#define kAnimationTime 3
在程序代码中多次使用同一个变量，可以用#define预处理指令来抽取，这样子可以达到第一层的抽取，在一般情况下面我们可以满足需求，利用define它会将kAnimationTime直接替换成3；所以这里如果定义在.h文件中，在其他引用了这个头文件的类中的kAnimationTime也会被替换，而且#define预处理指令是没有类型的，替换掉了也不清楚，可以在引用的地方修改定义好的值，有一定的风险，万一实在想用，记得注意命名问题和定义的位置。&lt;/p&gt;

&lt;h5&gt;2.定义常量跟#define预处理指令的区别&lt;/h5&gt;

&lt;p&gt;static const CGFloat kMargin = 10.0f；
可以明确的定义清楚类型，防止使用代码修改值，这样子在使用的过程减少出错。
定义名字的常用规则：需要限定在某编译单元(即本类中)则在前面添加k；
需要在其他类可见，一般是用此类的类名做前缀；
使用static修饰，是将该变量仅仅定义在该变量的编译单元中，如果不使用static修饰,编译器会为这个变量创建一个&amp;quot;外部符号&amp;quot;,此时其他类也声明了同名变量就会报错了。&lt;/p&gt;

&lt;h5&gt;3.全局常量，需要添加到“全局符号表中”&lt;/h5&gt;

&lt;p&gt;extern NSString *const PXYNotification;
NSString *const PXYNotification = @PXYNotification&amp;quot;&amp;quot;;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;##第5条 用枚举表示状态、选项、状态码&lt;/del&gt;
&lt;del&gt;###1.定义枚举的几种方式&lt;/del&gt;
&lt;del&gt;###2.按位与操作符&lt;/del&gt;
&lt;del&gt;###3.NS_ENUM与NS_OPTIONS宏的区别&lt;/del&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 28 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://pengxuyuan.github.io/2016/07/Effective-Objective-C-2.0-zongjie-one/</link>
        <guid isPermaLink="true">http://pengxuyuan.github.io/2016/07/Effective-Objective-C-2.0-zongjie-one/</guid>
        
        
      </item>
    
      <item>
        <title>iOS单例模式</title>
        <description>&lt;p&gt;单例 保证一个对象只实例化一次 全局使用的都是同一个对象&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一是某个类只能有一个实例；&lt;/li&gt;
&lt;li&gt;二是它必须自行创建这个实例；&lt;/li&gt;
&lt;li&gt;三是它必须自行向整个系统提供这个实例。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一种写法：
&lt;pre&gt; +(instancetype)shareInstance{&lt;br&gt;
static PXYGuidePageHelper *instance;&lt;br&gt;
        @synchronized(self) {&lt;br&gt;
            if (instance == nil) {&lt;br&gt;
                instance = [PXYGuidePageHelper new];&lt;br&gt;
            }&lt;br&gt;
        }&lt;br&gt;
    return instance;&lt;br&gt;
}&lt;br&gt;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;第二种写法：
&lt;pre&gt; +(instancetype)shareInstance{
    static dispatch_once_t onceToken;
    static PXYGuidePageHelper *instance;
    dispatch_once(&amp;amp;onceToken, &lt;sup&gt;{&lt;/sup&gt;
        instance = [PXYGuidePageHelper new];
    });
    return instance;
}
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;首先说下第一种写法：
单例实例是全局使用的，因此要要定义成全局变量 用static修饰 static介绍
@synchronized这个指令是解决多个线程同时执行同一个代码块 ，@synchronized相当于给这个代码块加锁（防止死锁）
这里判断当前对象时候存在，不存在创建，存在则返回该对象。&lt;/p&gt;

&lt;p&gt;第二种写法：
dispatch_once这个就是保证只执行一次 所以这里确保 该实例只创建一次&lt;/p&gt;

&lt;p&gt;两者区别：
第一种在每次执行shareInstance方法是都会加一次锁，然后在代码块里面判断 if (instance == nil) 这个来决定是否实例化，这里每次都会有开销。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;“实际上，如果你去看这个函数所在的头文件，你会发现目前它的实现其实是一个宏，进行了内联的初始化测试，这意味着通常情况下，你不用付出函数调用的负载代价，并且会有更少的同步控制负载。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这样子分析的GCD创建单例更加优雅点。&lt;/p&gt;

&lt;p&gt;－－－－&lt;br&gt;
第一种相当于是 懒汉式单例类 双检锁写法&lt;/p&gt;

&lt;p&gt;对于第一种的每次都要加锁的写法，可以使用双检锁写法来提高效率。
&lt;pre&gt;+(instancetype)shareInstance{
    static PXYGuidePageHelper *instance;
    if (instance == nil) {
        @synchronized(self) {
            if (instance == nil) {
                instance = [PXYGuidePageHelper new];
            }
        }
    }
    return instance;
}&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;这样子就能保证只有在第一次进行加锁开销。&lt;/p&gt;

&lt;p&gt;还有一种 饿汉式单例
是在程序一启动就实例化 +(void)load函数里面实现，然后在allocWithZone进行加锁判空操作，这样子无论你是否用特定的方法获取实例，都会返回同一个对象。&lt;/p&gt;

&lt;p&gt;以上&lt;/p&gt;
</description>
        <pubDate>Thu, 28 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://pengxuyuan.github.io/2016/07/iOS_SigleCase/</link>
        <guid isPermaLink="true">http://pengxuyuan.github.io/2016/07/iOS_SigleCase/</guid>
        
        
      </item>
    
      <item>
        <title>关于团队开发的编码规范</title>
        <description>&lt;p&gt;以下是均是个人看法，不喜勿喷，欢迎大家一起多多交流，共同进步。&lt;/p&gt;

&lt;p&gt;对于编码，每个人都有自己的习惯 ，但是我觉得要开发出优质代码的话有些规范还是要统一，毕竟你不是一个人做开发，你要考虑到团队协作以及后续人员维护你的项目，你想一下，让你维护一个别人的项目，上来就是ViewController几千行，所有页面逻辑全部在控制器里面，各种不能见名思义的变量属性，瞬间有种想死的感觉有木有😂😂😂所以吧，还是不要任性开发。&lt;/p&gt;

&lt;p&gt;说是对于团队开发的编码规范，其实在个人独立开发的时候也需要注意编码的问题，网上面有很多大神写的关于编码的blog，我就不复述了...&lt;/p&gt;

&lt;p&gt;这里我就写写最近在团队发开种遇到的问题吧，写的不全，后期遇到的其他问题都会贴上来的，一是提醒自己在编码过程中要规范，二是让大家看看我有什么地方理解错了，及时改正，三是，额，三是我写动手写点东西了，好久没写了....&lt;/p&gt;

&lt;p&gt;好了，入正题吧 不然又......&lt;/p&gt;

&lt;h5&gt;1.你要了解点MVC 最少你要知道我们还有View 跟 Model吧&lt;/h5&gt;

&lt;p&gt;哥哥，真的不要给我控制器里面写个几千行，我实在是维护不了，不要说维护了，估计在看懂你的逻辑之前我都已经挂了...&lt;/p&gt;

&lt;p&gt;现在项目开发中，最常用的就是MVC了，然后就是MVVM（我就只会这两个）有这两个开发一般般的项目我觉得够用了。控制器是拿来连接View跟Model的 扮演个协调者的角色 并不是要你把所有的逻辑写在里面。&lt;/p&gt;

&lt;h5&gt;2.我们先谈谈ViewController里面的一些东西&lt;/h5&gt;

&lt;p&gt;首先，不要把所有的属性变量放在.h文件里面。.h文件是暴露出去的，所以越简洁越好，坚持最少原则，用最少最简单的方式完成功能，你放在.h别人用的时候就可以随意操作你的暴露出去的东西了额，还有，我没搞懂为什么在.m文件里面实现的代理，声明要放在.h 比如说这个不要放在.h吧 实在是不好看，也没什么用。&lt;/p&gt;

&lt;p&gt;还有如果想更好点的话，在.h尽可能的用@class 这样子编译的压力小点 逼格也高点&lt;/p&gt;

&lt;p&gt;对于声明变量属性的话，到底是下面&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;｛
 UITableview  *tableview；
｝&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;还是&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;@property (nonatomic,strong) UITableView *tableview;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;哪个好呢，其实都还好，看个人，我比较喜欢下面那种，可以自动生成get set方法 用懒加载的时候也很是方便啊&lt;/p&gt;

&lt;p&gt;然后在使用的时候，也要注意下 不要一时用 _tableview 一时用self.tableview 一开始我是分别用的，后来看书看到，_tableview 跟self-&amp;gt;tableview 是直接访问地址的，self.tableview是通过消息机制调用get方法，所以呢，_tableview获取的比self. tableview快，所以折中的方法是，在内部读取数据时候尽量用_tableView，设置属性值时候，用self.tableview，这样子你可以通过重写set方法 更加可控 可调试点。&lt;/p&gt;

&lt;h5&gt;关于命名&lt;/h5&gt;

&lt;p&gt;额，命名这个东西老生常谈了，个人坚持的是，宁愿长也不要难认识。&lt;/p&gt;

&lt;h5&gt;函数摆放&lt;/h5&gt;

&lt;p&gt;个人有强迫症，所以比较会注意。&lt;/p&gt;

&lt;p&gt;比如生命周期函数写在一块 懒加载一块 网络请求一块 代理一块 事件一块&lt;/p&gt;

&lt;p&gt;用个#pragma mark - - 瞬间整个世界都有序了 有木有！！！&lt;/p&gt;

&lt;h5&gt;关于注释&lt;/h5&gt;

&lt;p&gt;说到这里，再说下关于注释这东西。通常说法是：程序员最讨厌别人不写注释和自己写注释。&lt;/p&gt;

&lt;p&gt;其实个人我是坚持代码即注释，就是比较讨厌注释的，觉得好的代码不需要注释。&lt;/p&gt;

&lt;p&gt;我总感觉注释很脏啊- -  总感觉多了点什么。（个人强迫症原因....）&lt;/p&gt;

&lt;p&gt;吐槽下，接手的项目全部是注释，关键是注释都没什么用啊.....&lt;/p&gt;

&lt;p&gt;生命周期函数全部写一次注释，这些不写 新生都知道是干嘛的啊- -&lt;/p&gt;

&lt;p&gt;关键是.m文件你的注释为什么要写成这样子呢？&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;/**
*
*初始化方法
*@return self
*/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;每个生命周期都是这样子，是真的烦，反正看到的我都删除了。&lt;/p&gt;

&lt;h5&gt;3.关于View&lt;/h5&gt;

&lt;p&gt;个人观点：凡事复杂点的组件（你在屏幕上看到的东西） 都自己写个view出来 不要在ViewController里面写你View里面的布局逻辑，这样子控制器本来不胖的都被你搞胖了😂😂😂&lt;/p&gt;

&lt;p&gt;额，还有，发现很多人虽然写了View 但是 但是 他把View的控件属性全部写在.h里面 然后在ViewController里面直接赋值，这样子还真没搞懂你的View到底是干嘛的 也不能只写布局啊。自己的东西自己管啊，View.h 暴露个Model，ViewController传个Model就好了啊 再不济你传个字典也比在ViewController直接赋值的好啊。&lt;/p&gt;

&lt;p&gt;最后就是：自己的事情自己做&lt;/p&gt;

&lt;p&gt;而还有，不要滥用自定义View 我最近看到一种写法是 View嵌入View然后再嵌入View再嵌入View....太恶心了&lt;/p&gt;

&lt;p&gt;更甚的是，全部写在.h中 设置属性的就是在控制器self.view.view.view.text 然后增加事件就是 self.view.view.view addTag&lt;/p&gt;

&lt;p&gt;看到这个我心中无数只草泥马啊。。。&lt;/p&gt;

&lt;p&gt;善用代理跟block 这样子代码好看还解藕了，多好。&lt;/p&gt;

&lt;p&gt;最近还看到一种用协议来创建自定义View的 是真的厉害 高内聚 代码一下子就可以看懂了 而且逼格一下子就上去了。&lt;/p&gt;

&lt;p&gt;网址：&lt;a href=&quot;http://reviewcode.cn/article.html?reviewId=5&quot;&gt;自定义UI控件&lt;/a&gt;&lt;/p&gt;

&lt;h5&gt;其他&lt;/h5&gt;

&lt;p&gt;额 说到逼格  最近学到 定义常量少用&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;#define&lt;/p&gt;

&lt;p&gt;用static const CGFloat kBorderMargin = 15;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这样子会比较好，可以预先知道类型，减少出错的机会。&lt;/p&gt;

&lt;h5&gt;4.现在的文件命名还不错，都是峰驼式的。&lt;/h5&gt;

&lt;h5&gt;5.封装思想，重用组件。&lt;/h5&gt;

&lt;p&gt;编码的时候做个懒人。&lt;/p&gt;

&lt;p&gt;不要重复的写一样的代码，还不好改。具体的，也不好写，思想大概就是多处用到的一样的东西，抽出来，不要copy代码。&lt;/p&gt;

&lt;h5&gt;The End&lt;/h5&gt;

&lt;p&gt;这篇文章就是拿来练习下markdown的，刚学。&lt;/p&gt;
</description>
        <pubDate>Mon, 13 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://pengxuyuan.github.io/2016/06/CodingStandardsForTeamDevelopment/</link>
        <guid isPermaLink="true">http://pengxuyuan.github.io/2016/06/CodingStandardsForTeamDevelopment/</guid>
        
        
      </item>
    
  </channel>
</rss>
