<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>彭序猿</title>
    <description>你好，我是彭序猿，目前在iOS开发的道路上探索，这里会写点关于iOS开发blog，还有一些生活上的琐碎事儿。</description>
    <link>http://pengxuyuan.github.io/</link>
    <atom:link href="http://pengxuyuan.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 21 Apr 2017 11:10:37 +0800</pubDate>
    <lastBuildDate>Fri, 21 Apr 2017 11:10:37 +0800</lastBuildDate>
    <generator>Jekyll v3.1.1</generator>
    
      <item>
        <title>NSTimer 知识点</title>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h3&gt;NSTimer 是什么&lt;/h3&gt;

&lt;p&gt;定时器 一般都是用来做一些周期性的任务&lt;/p&gt;

&lt;h3&gt;使用遇到什么问题&lt;/h3&gt;

&lt;p&gt;内存释放问题、定时器失效问题&lt;/p&gt;

&lt;h3&gt;为什么会出现这些问题&lt;/h3&gt;

&lt;h4&gt;内存释放问题&lt;/h4&gt;

&lt;p&gt;当定时器被加到run loop 生效的时候，run loop 会强引用这个定时器对象（retain），然后定时器又会强引用这个Target 对象，这样子就会导致这个定时器一直存在，这个Target 对象一直存在，导致一直释放不了&lt;/p&gt;

&lt;p&gt;单纯将NSTimer置为nil，是不能使定时器失效的，runloop 已经强引用这个timer 了，要使得定时器失效需要调用invalidate 方法&lt;/p&gt;

&lt;h4&gt;定时器失效问题  （场景：滑动TableView 的时候，定时器失效）&lt;/h4&gt;

&lt;p&gt;run loop 里面有很多模式，但是一个时间点只会处在一个模式下，在某个模式的时候，只会处理和调度这个模式下面的事件和资源，NSTimer 在用scheduledTimerWithTimeInterval 生成的时候是以默认模式加入到当前的run loop，然后模式是NSDefaultRunLoopMode，但是当TableView 滑动的时run loop 会切换到UITrackingRunLoopMode 这个模式，所以此时NSTimer 就会失效&lt;/p&gt;

&lt;p&gt;所以这里是：当run loop 切换到不是timer 加入run loop 时的模式时，这个定时器就会暂时失效&lt;/p&gt;

&lt;h4&gt;关于手动将timer 置为nil 的意义&lt;/h4&gt;

&lt;p&gt;一个变量，如果被 strong 修饰，和被 weak 修饰，是有一定的区别的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;strong&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;若一个变量被 strong 修饰 （临时变量或者非 property 变量默认 strong 修饰），则其为强指针指向，在被赋值的时候，会强引用赋值对象。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;weak&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;若一个变量被 weak 修饰，则其为弱指针指向，弱指针指向的对象，如果没有被外界进行强引用的话，会在初始化方法完成之后，将变量置空。&lt;/p&gt;

&lt;p&gt;在 timer 被 strong 和 weak 修饰时的区别&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果 timer 被 strong 修饰，那么 timer 会被 self 持有一次，加入 runloop 之后，会被 runloop 再持有一次，invalidate 只会解除 runloop 对 timer 的持有，self 还是会 持有 timer ，所以需要手动置为 nil ，解除 self 对 timer 的持有。&lt;/li&gt;
&lt;li&gt;如果 timer 被 weak 修饰，那么 timer 不会被 self 持有，只是 runloop 对 timer 有一次持有（==前提是外界没有持有该timer，如果外界持有了，需要外界也手动置空==），invalidate 解除了 runloop 对 timer 的持有之后，系统会自动将 timer 置空。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果我们用了懒加载，而且 timer 是weak 修饰，没有初始化过，在下面这种写法的时候，&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;[self.timer invalidate];
NSLog(@&amp;quot;%@&amp;quot;, _timer);
[self.timer fire];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;会发现，打印出来的 _timer 依然有值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;原因是&lt;/strong&gt;：因为 timer 并没有被初始化，我们在调用 &lt;code&gt;self.timer&lt;/code&gt; 的时候，会走get方法，因为我们在 get 方法里做了懒加载，就会走一遍初始化，但是我们又在初始化方法里，加进了 runloop ，runloop 强引用了 timer ，那么在 get 方法执行完之后，timer 并不会被销毁。但是，我们又调用了 invalidate ，这个操作只会解除 runloop 对 timer 的持有，引用计数 -1，却并不会立即将 timer 置为 nil ，所以在 调用打 log 和  &lt;code&gt;[self.timer fier]&lt;/code&gt; 的时候，get 方法并不会走初始化操作了，但是因为 timer 已经不被 runloop 强引用了，所以会失效。&lt;/p&gt;

&lt;h4&gt;关于调用invalidate 方式&lt;/h4&gt;

&lt;p&gt;在调用invalidate 是否需要用valid 来判断，懒加载的情况是需要的，因为会被置为nil，多次调用的时候会重新创建，但是直接会被invalidate，这里定位会比较麻烦
invalidate 这个是使定时器失效的，调用的时候不能dealloc 里面去调用，因为run loop 强引用了定时器，定时器又强引用了Target 对象，这个时候VC 是不会被释放的，自然不会走dealloc 方法&lt;/p&gt;

&lt;h4&gt;关于NSTimer 暂停开始&lt;/h4&gt;

&lt;p&gt;这里最优雅的方式就是写一个NSTimer 的分类，然后用fireDate 触发时间来处理&lt;/p&gt;

&lt;h3&gt;如何正确使用&lt;/h3&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;#pragma mark - Lazzy load
- (NSTimer *)timer {
    if (_timer == nil) {
        _timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(timerStep) userInfo:nil repeats:YES];
    }
    return _timer;
}

-(void)viewDidDisappear:(BOOL)animated {
    [super viewDidDisappear:animated];

    if ([self.timer isValid]) {
        [self.timer invalidate];
        self.timer = nil;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h3&gt;NSTimer 官方文档介绍&lt;/h3&gt;

&lt;h4&gt;NSTimer&lt;/h4&gt;

&lt;p&gt;你可以用NSTimer 这个类来创建定时器对象。定时器会等待一个时间间隔然后触发，向一个目标对象（Target）发送特定的消息。例如你可以创建一个定时器对象，发消息到window，告诉它隔一段时间就更新自己&lt;/p&gt;

&lt;h4&gt;Overview&lt;/h4&gt;

&lt;p&gt;定时器跟run loop 一起工作，要有效地使用定时器，你应该注意run loop 的运行机制 — 可以参阅NSRunLoop 和Threading Programming Guide 章节。特别注意，run loop 会对run loop 中的定时器维持强引用，所以你不需要在把这个定时器加入到run loop 后对它维持强引用&lt;/p&gt;

&lt;p&gt;定时器并不是一个实时机制；只有run loop 正在运行的模式是定时器加到run loop 的模式时候并且检查到这个定时器的触发时间是否过去，这样子定时器才会触发。（run loop 有很多种模式，但是一个时间点只会处在一个模式下，然后定时器加入到run loop 也是可以设置需要加入到run loop 什么模式下的）因为有存在各种输入源，run loop 是典型的循环运行管理，所以定时器间隔的有效分辨是在50-100毫秒量级。如果定时器要触发的时候出现了一个耗时的操作或者当前run loop 模式不是定时器加入时候的模式，这样子定时器是不会被触发的直到下次run loop 检查定时器。&lt;/p&gt;

&lt;p&gt;因此，定时器的触发的实际时间有可能是预定触发时间之后的相当长的一段时间，另请参考&lt;a href=&quot;#Timer%20Tolerance&quot;&gt;Timer Tolerance&lt;/a&gt;章节&lt;/p&gt;

&lt;p&gt;NSTimer 跟 Core Foundation的CFRunLoopTimerRef是“toll-free bridge”，有关toll-free bridging 信息请参考Toll-free Bridging 章节&lt;/p&gt;

&lt;h4&gt;Repeating Versus Non-Repeating Timers （重复与不重复定时器）&lt;/h4&gt;

&lt;p&gt;你在创建定时器可以指定是重复的还是不重复的。不重复定时器触发一次，然后会自动的使其自动失效，从而防止定时器再次触发。相比之下，重复定时器会在相同的run loop 上面触发并且重新排列&lt;/p&gt;

&lt;p&gt;重复定时器总是根据预定的触发时间自动安排，而不是根据实际的触发时间。例如，如果定时器计划在一个特定的时间点和之后的每5秒触发， 尽管实际的触发时间延迟了，预定的触发时间依然是在原始时间点的之后5秒，如果触发时间被延迟到它下一个（或者下几个）触发时间，则这个时间段定时器只会触发一次，然后定时器在触发后会重新排列，等待下一个预定的触发时间&lt;/p&gt;

&lt;h4&gt;Timer Tolerance 定时器误差&lt;/h4&gt;

&lt;p&gt;在iOS 7及更高版本以及macOS 10.9及更高版本中，你可以指定定时器的的误差。误差可以使得在定时器触发的时候系统更加灵活，可以提高系统的优化能力，从而提高功率节省和响应能力。 定时器会在预定的触发时间点和预定触发时间点加上误差时间之间触发(A&amp;lt;-&amp;gt;A+误差)。计时器不会在预定触发时间点之前触发。对于重复定时器，下一个触发时间是从原始时间点开始计算的，不会因为个别触发时间的误差来重新计算，避免时间点偏移。误差值默认是0，这就意味着不会加上误差，但是系统保留对某个定时器触发加上一个很小的误差的权利，这个时候不会考虑这个误差属性&lt;/p&gt;

&lt;p&gt;使用定时器，你最好了解一个合适的定时器误差值。一般的经验法则是将这个误差值最少设置成定时器间隔的10%，尽管是一个很小的误差值，也会对应用程序的耗电产生很大的积极影响。&lt;/p&gt;

&lt;h4&gt;Scheduling Timers in Run Loops&lt;/h4&gt;

&lt;p&gt;一个定时器对象只能在run loop 中注册一次，尽管它可以被加到run loop 中的不同的run loop模式中去，这里有3中方法创建定时器：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Use the scheduledTimerWithTimeInterval:invocation:repeats: or scheduledTimerWithTimeInterval:target : selector:userInfo:repeats: class method to create the timer and schedule it on the current run loop in the default mode.&lt;/p&gt;

&lt;p&gt;用这两个类方法创建定时器对象，会将这个定时器对象以默认run loop 模式（NSDefaultRunLoopMode）加到当前的run loop 中&lt;/p&gt;

&lt;p&gt;Use the timerWithTimeInterval:invocation:repeats: or timerWithTimeInterval`:targetselector:userInfo:repeats: class method to create the timer object without scheduling it on a run loop. (After creating it, you must add the timer to a run loop manually by calling the addTimer:forMode: method of the corresponding NSRunLoop object.)&lt;/p&gt;

&lt;p&gt;用这个两个类方法创建定时器对象，不会将这个对象加入到run loop 中，在创建对象后，你必须手动的将这个定时器对象加入到一个run loop 中，[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];&lt;/p&gt;

&lt;p&gt;Allocate the timer and initialize it using the initWithFireDate:interval:target :selector:userInfo:repeats: method. (After creating it, you must add the timer to a run loop manually by calling the addTimer:forMode: method of the corresponding NSRunLoop object.)
在创建对象后，你必须手动的将这个定时器对象加入到一个run loop 中，[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一旦添加到run loop中，定时器会在指定的时间间隔触发直到这个定时器失效（invalidate）。一个不重复的定时器在触发后立即使其自动失效。但是对于重复的定时器调用invalidate 才能使它失效。调用invalidate 这个方法会从当前的run loop 中移除这个定时器。因此你应该在创建这个定时器的线程调用这个invalidate 方法。会立即使这个定时器失效，使其不再影响这个run loop。在invalidate 方法返回前后，这个run loop 会移除这个定时器和对这个定时器的强引用。一旦失效，这个定时器对象不能被重用&lt;/p&gt;

&lt;p&gt;在重复定时器触发之后，它会安排下一次预定时间点的触发，这个时间点是上一次触发时间点间隔的整数倍，在公差范围内。如果调用选择器方法或者调用NSInvocation 花费的时间长于定时器的间隔时间，则这个定时器会安排在下一次再触发，也就是说，定时器不会尝试补偿在调用选择器方法或调用NSInvocation 过久导致错过启动时间。&lt;/p&gt;

&lt;h4&gt;Subclassing Notes&lt;/h4&gt;

&lt;p&gt;你不应该尝试去创建NSTimer 的子类  Crash&lt;/p&gt;

&lt;h4&gt;Symbols&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/pengxuyuan/quzhibo/master/NSTimer/B9E579FA-AF03-43E2-AB2C-31F7C742D5B7.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h4&gt;Relationships&lt;/h4&gt;

&lt;p&gt;Inherits From NSObject&lt;/p&gt;
</description>
        <pubDate>Fri, 21 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://pengxuyuan.github.io/2017/04/NSTimer/</link>
        <guid isPermaLink="true">http://pengxuyuan.github.io/2017/04/NSTimer/</guid>
        
        
      </item>
    
      <item>
        <title>Effective Objective-C 2.0 总结（一）</title>
        <description>&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;阅读书籍全名&lt;a href=&quot;http://item.jd.com/11402853.html&quot;&gt;Effective Objective-C 2.0 编写高质量iOS与OS X 代码的52个有效方法&lt;/a&gt;
最经买了本&lt;a href=&quot;http://item.jd.com/11779514.html&quot;&gt;编写高质量代码 改善Objective-C程序的61个建议&lt;/a&gt;，拿到手看了下目录感觉内容比这本52个有效方法更深点，之前只是浅度这本，具体讲什么也不是很记得了，所以打算先重新看下这本52个有效方法，然后再来拜读新入手的这本。&lt;/p&gt;

&lt;p&gt;这里准备记录下&lt;a href=&quot;http://item.jd.com/11402853.html&quot;&gt;Effective Objective-C 2.0 编写高质量iOS与OS X 代码的52个有效方法&lt;/a&gt;这本提到的知识点。&lt;/p&gt;

&lt;h3&gt;第一章 熟悉Objective-C&lt;/h3&gt;

&lt;h4&gt;第1条 了解Objective-C的起源&lt;/h4&gt;

&lt;p&gt;1.OC是C语音的超集，在C的基础上面添加了面向对象特征，并且是使用了消息结构并非函数调用。
超集的意思大概就是爸爸跟儿子，S1就是S2的超集；
&lt;img src=&quot;http://7xnp79.com1.z0.glb.clouddn.com/64380cd7912397dd663433635f82b2b7d0a2870c.png&quot; alt=&quot;&quot;&gt;
消息结构与函数调用的区别是：消息结构最终执行的代码块是由运行环境决定的，函数调用的代码块有编译器决定，在编译的时候已经确定好。&lt;/p&gt;

&lt;p&gt;2.面向过程与面向对象的区别
这个说实话我也不知道怎么解释 突然感觉很难回答这个问题&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。
面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;3.OC中的动态库与静态库
博客：&lt;br&gt;
&lt;a href=&quot;http://www.cnblogs.com/cmx-ios2014/p/3802618.html?utm_source=tuicool&amp;amp;utm_medium=referral&quot;&gt;http://www.cnblogs.com/cmx-ios2014/p/3802618.html?utm_source=tuicool&amp;amp;utm_medium=referral&lt;/a&gt;
&lt;a href=&quot;http://www.jianshu.com/p/42070c513104&quot;&gt;http://www.jianshu.com/p/42070c513104&lt;/a&gt;
&lt;a href=&quot;http://www.cnblogs.com/striveLD/p/5752010.html&quot;&gt;http://www.cnblogs.com/striveLD/p/5752010.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4.C语言中的内存模型&lt;br&gt;
&lt;a href=&quot;http://www.cnblogs.com/haore147/p/3921263.html&quot;&gt;http://www.cnblogs.com/haore147/p/3921263.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;5.内存中的堆空间(heap space) 栈(stack)&lt;br&gt;
分配在堆中的内存必须直接管理，分配在栈上用于保存变量的内存则会在栈帧弹出式自动清理。&lt;/p&gt;

&lt;p&gt;6.不能在栈上面分配OC对象&lt;/p&gt;

&lt;p&gt;7.CGRect不属于OC对象
相比于结构体，创建对象需要额外的开销，比如分配及释放内存堆，所以在操作一对非OC对象是，可以考虑用结构体来操作。&lt;/p&gt;

&lt;h4&gt;第2条 在类的头文件中尽量少引用其他头文件&lt;/h4&gt;

&lt;p&gt;1.A类的头文件中有一个B类型的属性&lt;br&gt;
引用头文件的方式有3种：#import #incudule @class关键字&lt;br&gt;
首先说明#import是由gcc编译器支持的，其实就是#incudule改良版本&lt;br&gt;
#import确保了引用的这个文件只被引进一次，而#incudule就会出现死循环引用，导致程序报错；&lt;br&gt;
@class关键字“向前声明”告诉你有这个类，具体定义不清楚，这样子可以解决引用无法识别该对象的问题，也解决了循环引用的问题&lt;br&gt;
#import #incudule 引进类来，会拿到这个类的头文件的信息了，这里违反了最少原则，所以一般在.h头文件中尽量少用；&lt;br&gt;
使用@class可以减少.h中对其他类的依赖、减少链接到其他类所需要的时间，从而降低编译时间；  &lt;/p&gt;

&lt;p&gt;一般来说在.h中，首选@class 然后在迫不得已的时候才用#import(继承，实现协议)&lt;br&gt;
对于协议来说 可以使用类扩展在.m中申明一个匿名类别来声明，只有在子类需要统一实现这个协议的时候才会放在.h中，暂时没有了解到其他情况得非在.h中#import协议。  &lt;/p&gt;

&lt;p&gt;2.两个类互相引用的问题 A类中有B类的属性 B类中也有A类的属性&lt;br&gt;
使用#incudule这样子会报错，但是使用#import的话只能保证一个类被编译到了，也是用问题的，在这里只能用@class解决这个循环引用的问题。  &lt;/p&gt;

&lt;p&gt;&lt;del&gt;3.在实现文件中声明此类实现了该委托协议，并把这段代码放在“class-continuation”分类中&lt;/del&gt;&lt;/p&gt;

&lt;h4&gt;第3条 多使用字面量语法，少用与之等价的方法&lt;/h4&gt;

&lt;p&gt;1.好处缩减代码长度，更加易读&lt;/p&gt;

&lt;p&gt;2.对于字面量数组/字典来说，对象中有nil会抛出异常&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;NSArray *array = @[@&amp;quot;&amp;quot;,@&amp;quot;&amp;quot;,@&amp;quot;&amp;quot;];&lt;/p&gt;

&lt;p&gt;NSDictionary *dictionary = @{key:value}；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;3.糖衣语法(语法糖)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;糖衣语法，又叫‘语法糖’、‘语法盐’等等，是由英国计算机科学家彼得·约翰·兰达（Peter J.Landin）发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;额，就是简单粗暴，减少出错；&lt;/p&gt;

&lt;p&gt;&lt;del&gt;4.字面量语法 非字面量语法&lt;/del&gt;&lt;/p&gt;

&lt;h4&gt;第4条 多用类型常量，少用#define预处理指令&lt;/h4&gt;

&lt;p&gt;1.#define预处理指令
#define kAnimationTime 3&lt;br&gt;
在程序代码中多次使用同一个变量，可以用#define预处理指令来抽取，这样子可以达到第一层的抽取，在一般情况下面我们可以满足需求，利用define它会将kAnimationTime直接替换成3；所以这里如果定义在.h文件中，在其他引用了这个头文件的类中的kAnimationTime也会被替换，而且#define预处理指令是没有类型的，替换掉了也不清楚，可以在引用的地方修改定义好的值，有一定的风险，万一实在想用，记得注意命名问题和定义的位置。  &lt;/p&gt;

&lt;p&gt;2.定义常量跟#define预处理指令的区别
static const CGFloat kMargin = 10.0f；&lt;br&gt;
可以明确的定义清楚类型，防止使用代码修改值，这样子在使用的过程减少出错。&lt;br&gt;
定义名字的常用规则：需要限定在某编译单元(即本类中)则在前面添加k；&lt;br&gt;
需要在其他类可见，一般是用此类的类名做前缀；&lt;br&gt;
使用static修饰，是将该变量仅仅定义在该变量的编译单元中，如果不使用static修饰,编译器会为这个变量创建一个&amp;quot;外部符号&amp;quot;,此时其他类也声明了同名变量就会报错了。&lt;/p&gt;

&lt;p&gt;3.全局常量，需要添加到“全局符号表中”&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;extern NSString *const PXYNotification;  &lt;/p&gt;

&lt;p&gt;NSString *const PXYNotification = @PXYNotification&amp;quot;&amp;quot;;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;del&gt;####第5条 用枚举表示状态、选项、状态码&lt;/del&gt;
&lt;del&gt;1.定义枚举的几种方式&lt;/del&gt;
&lt;del&gt;2.按位与操作符&lt;/del&gt;
&lt;del&gt;3.NS_ENUM与NS_OPTIONS宏的区别&lt;/del&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 28 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://pengxuyuan.github.io/2016/07/Effective-Objective-C-2.0-zongjie-one/</link>
        <guid isPermaLink="true">http://pengxuyuan.github.io/2016/07/Effective-Objective-C-2.0-zongjie-one/</guid>
        
        
      </item>
    
      <item>
        <title>iOS单例模式</title>
        <description>&lt;p&gt;单例 保证一个对象只实例化一次 全局使用的都是同一个对象&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一是某个类只能有一个实例；&lt;/li&gt;
&lt;li&gt;二是它必须自行创建这个实例；&lt;/li&gt;
&lt;li&gt;三是它必须自行向整个系统提供这个实例。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一种写法：
&lt;pre&gt; +(instancetype)shareInstance{&lt;br&gt;
static PXYGuidePageHelper *instance;&lt;br&gt;
        @synchronized(self) {&lt;br&gt;
            if (instance == nil) {&lt;br&gt;
                instance = [PXYGuidePageHelper new];&lt;br&gt;
            }&lt;br&gt;
        }&lt;br&gt;
    return instance;&lt;br&gt;
}&lt;br&gt;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;第二种写法：
&lt;pre&gt; +(instancetype)shareInstance{
    static dispatch_once_t onceToken;
    static PXYGuidePageHelper *instance;
    dispatch_once(&amp;amp;onceToken, &lt;sup&gt;{&lt;/sup&gt;
        instance = [PXYGuidePageHelper new];
    });
    return instance;
}
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;首先说下第一种写法：
单例实例是全局使用的，因此要要定义成全局变量 用static修饰 static介绍
@synchronized这个指令是解决多个线程同时执行同一个代码块 ，@synchronized相当于给这个代码块加锁（防止死锁）
这里判断当前对象时候存在，不存在创建，存在则返回该对象。&lt;/p&gt;

&lt;p&gt;第二种写法：
dispatch_once这个就是保证只执行一次 所以这里确保 该实例只创建一次&lt;/p&gt;

&lt;p&gt;两者区别：
第一种在每次执行shareInstance方法是都会加一次锁，然后在代码块里面判断 if (instance == nil) 这个来决定是否实例化，这里每次都会有开销。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;“实际上，如果你去看这个函数所在的头文件，你会发现目前它的实现其实是一个宏，进行了内联的初始化测试，这意味着通常情况下，你不用付出函数调用的负载代价，并且会有更少的同步控制负载。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这样子分析的GCD创建单例更加优雅点。&lt;/p&gt;

&lt;p&gt;－－－－&lt;br&gt;
第一种相当于是 懒汉式单例类 双检锁写法&lt;/p&gt;

&lt;p&gt;对于第一种的每次都要加锁的写法，可以使用双检锁写法来提高效率。
&lt;pre&gt;+(instancetype)shareInstance{
    static PXYGuidePageHelper *instance;
    if (instance == nil) {
        @synchronized(self) {
            if (instance == nil) {
                instance = [PXYGuidePageHelper new];
            }
        }
    }
    return instance;
}&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;这样子就能保证只有在第一次进行加锁开销。&lt;/p&gt;

&lt;p&gt;还有一种 饿汉式单例
是在程序一启动就实例化 +(void)load函数里面实现，然后在allocWithZone进行加锁判空操作，这样子无论你是否用特定的方法获取实例，都会返回同一个对象。&lt;/p&gt;

&lt;p&gt;以上&lt;/p&gt;
</description>
        <pubDate>Thu, 28 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://pengxuyuan.github.io/2016/07/iOS_SigleCase/</link>
        <guid isPermaLink="true">http://pengxuyuan.github.io/2016/07/iOS_SigleCase/</guid>
        
        
      </item>
    
      <item>
        <title>关于团队开发的编码规范</title>
        <description>&lt;p&gt;以下是均是个人看法，不喜勿喷，欢迎大家一起多多交流，共同进步。&lt;/p&gt;

&lt;p&gt;对于编码，每个人都有自己的习惯 ，但是我觉得要开发出优质代码的话有些规范还是要统一，毕竟你不是一个人做开发，你要考虑到团队协作以及后续人员维护你的项目，你想一下，让你维护一个别人的项目，上来就是ViewController几千行，所有页面逻辑全部在控制器里面，各种不能见名思义的变量属性，瞬间有种想死的感觉有木有😂😂😂所以吧，还是不要任性开发。&lt;/p&gt;

&lt;p&gt;说是对于团队开发的编码规范，其实在个人独立开发的时候也需要注意编码的问题，网上面有很多大神写的关于编码的blog，我就不复述了...&lt;/p&gt;

&lt;p&gt;这里我就写写最近在团队发开种遇到的问题吧，写的不全，后期遇到的其他问题都会贴上来的，一是提醒自己在编码过程中要规范，二是让大家看看我有什么地方理解错了，及时改正，三是，额，三是我写动手写点东西了，好久没写了....&lt;/p&gt;

&lt;p&gt;好了，入正题吧 不然又......&lt;/p&gt;

&lt;h5&gt;1.你要了解点MVC 最少你要知道我们还有View 跟 Model吧&lt;/h5&gt;

&lt;p&gt;哥哥，真的不要给我控制器里面写个几千行，我实在是维护不了，不要说维护了，估计在看懂你的逻辑之前我都已经挂了...&lt;/p&gt;

&lt;p&gt;现在项目开发中，最常用的就是MVC了，然后就是MVVM（我就只会这两个）有这两个开发一般般的项目我觉得够用了。控制器是拿来连接View跟Model的 扮演个协调者的角色 并不是要你把所有的逻辑写在里面。&lt;/p&gt;

&lt;h5&gt;2.我们先谈谈ViewController里面的一些东西&lt;/h5&gt;

&lt;p&gt;首先，不要把所有的属性变量放在.h文件里面。.h文件是暴露出去的，所以越简洁越好，坚持最少原则，用最少最简单的方式完成功能，你放在.h别人用的时候就可以随意操作你的暴露出去的东西了额，还有，我没搞懂为什么在.m文件里面实现的代理，声明要放在.h 比如说这个不要放在.h吧 实在是不好看，也没什么用。&lt;/p&gt;

&lt;p&gt;还有如果想更好点的话，在.h尽可能的用@class 这样子编译的压力小点 逼格也高点&lt;/p&gt;

&lt;p&gt;对于声明变量属性的话，到底是下面&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;｛
 UITableview  *tableview；
｝&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;还是&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;@property (nonatomic,strong) UITableView *tableview;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;哪个好呢，其实都还好，看个人，我比较喜欢下面那种，可以自动生成get set方法 用懒加载的时候也很是方便啊&lt;/p&gt;

&lt;p&gt;然后在使用的时候，也要注意下 不要一时用 _tableview 一时用self.tableview 一开始我是分别用的，后来看书看到，_tableview 跟self-&amp;gt;tableview 是直接访问地址的，self.tableview是通过消息机制调用get方法，所以呢，_tableview获取的比self. tableview快，所以折中的方法是，在内部读取数据时候尽量用_tableView，设置属性值时候，用self.tableview，这样子你可以通过重写set方法 更加可控 可调试点。&lt;/p&gt;

&lt;h5&gt;关于命名&lt;/h5&gt;

&lt;p&gt;额，命名这个东西老生常谈了，个人坚持的是，宁愿长也不要难认识。&lt;/p&gt;

&lt;h5&gt;函数摆放&lt;/h5&gt;

&lt;p&gt;个人有强迫症，所以比较会注意。&lt;/p&gt;

&lt;p&gt;比如生命周期函数写在一块 懒加载一块 网络请求一块 代理一块 事件一块&lt;/p&gt;

&lt;p&gt;用个#pragma mark - - 瞬间整个世界都有序了 有木有！！！&lt;/p&gt;

&lt;h5&gt;关于注释&lt;/h5&gt;

&lt;p&gt;说到这里，再说下关于注释这东西。通常说法是：程序员最讨厌别人不写注释和自己写注释。&lt;/p&gt;

&lt;p&gt;其实个人我是坚持代码即注释，就是比较讨厌注释的，觉得好的代码不需要注释。&lt;/p&gt;

&lt;p&gt;我总感觉注释很脏啊- -  总感觉多了点什么。（个人强迫症原因....）&lt;/p&gt;

&lt;p&gt;吐槽下，接手的项目全部是注释，关键是注释都没什么用啊.....&lt;/p&gt;

&lt;p&gt;生命周期函数全部写一次注释，这些不写 新生都知道是干嘛的啊- -&lt;/p&gt;

&lt;p&gt;关键是.m文件你的注释为什么要写成这样子呢？&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;/**
*
*初始化方法
*@return self
*/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;每个生命周期都是这样子，是真的烦，反正看到的我都删除了。&lt;/p&gt;

&lt;h5&gt;3.关于View&lt;/h5&gt;

&lt;p&gt;个人观点：凡事复杂点的组件（你在屏幕上看到的东西） 都自己写个view出来 不要在ViewController里面写你View里面的布局逻辑，这样子控制器本来不胖的都被你搞胖了😂😂😂&lt;/p&gt;

&lt;p&gt;额，还有，发现很多人虽然写了View 但是 但是 他把View的控件属性全部写在.h里面 然后在ViewController里面直接赋值，这样子还真没搞懂你的View到底是干嘛的 也不能只写布局啊。自己的东西自己管啊，View.h 暴露个Model，ViewController传个Model就好了啊 再不济你传个字典也比在ViewController直接赋值的好啊。&lt;/p&gt;

&lt;p&gt;最后就是：自己的事情自己做&lt;/p&gt;

&lt;p&gt;而还有，不要滥用自定义View 我最近看到一种写法是 View嵌入View然后再嵌入View再嵌入View....太恶心了&lt;/p&gt;

&lt;p&gt;更甚的是，全部写在.h中 设置属性的就是在控制器self.view.view.view.text 然后增加事件就是 self.view.view.view addTag&lt;/p&gt;

&lt;p&gt;看到这个我心中无数只草泥马啊。。。&lt;/p&gt;

&lt;p&gt;善用代理跟block 这样子代码好看还解藕了，多好。&lt;/p&gt;

&lt;p&gt;最近还看到一种用协议来创建自定义View的 是真的厉害 高内聚 代码一下子就可以看懂了 而且逼格一下子就上去了。&lt;/p&gt;

&lt;p&gt;网址：&lt;a href=&quot;http://reviewcode.cn/article.html?reviewId=5&quot;&gt;自定义UI控件&lt;/a&gt;&lt;/p&gt;

&lt;h5&gt;其他&lt;/h5&gt;

&lt;p&gt;额 说到逼格  最近学到 定义常量少用&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;#define&lt;/p&gt;

&lt;p&gt;用static const CGFloat kBorderMargin = 15;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这样子会比较好，可以预先知道类型，减少出错的机会。&lt;/p&gt;

&lt;h5&gt;4.现在的文件命名还不错，都是峰驼式的。&lt;/h5&gt;

&lt;h5&gt;5.封装思想，重用组件。&lt;/h5&gt;

&lt;p&gt;编码的时候做个懒人。&lt;/p&gt;

&lt;p&gt;不要重复的写一样的代码，还不好改。具体的，也不好写，思想大概就是多处用到的一样的东西，抽出来，不要copy代码。&lt;/p&gt;

&lt;h5&gt;The End&lt;/h5&gt;

&lt;p&gt;这篇文章就是拿来练习下markdown的，刚学。&lt;/p&gt;
</description>
        <pubDate>Mon, 13 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://pengxuyuan.github.io/2016/06/CodingStandardsForTeamDevelopment/</link>
        <guid isPermaLink="true">http://pengxuyuan.github.io/2016/06/CodingStandardsForTeamDevelopment/</guid>
        
        
      </item>
    
  </channel>
</rss>
