<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>彭序猿</title>
    <description>你好，我是彭序猿，目前在iOS开发的道路上探索，这里会写点关于iOS开发blog，还有一些生活上的琐碎事儿。</description>
    <link>http://pengxuyuan.github.io/</link>
    <atom:link href="http://pengxuyuan.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 23 May 2017 00:43:53 +0800</pubDate>
    <lastBuildDate>Tue, 23 May 2017 00:43:53 +0800</lastBuildDate>
    <generator>Jekyll v3.1.1</generator>
    
      <item>
        <title>Effective Objective-C 2.0 总结（五）</title>
        <description>&lt;h2&gt;内存管理&lt;/h2&gt;

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h3&gt;第 29 条：理解引用计数&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;引用计数工作原理&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Objective-C 语言使用引用计数来管理内存，每个对象都有个可以递增递减的计数器，用以表示当前有多少个事物想令此对象继续存活下去。&lt;/li&gt;
&lt;li&gt;NSObject 协议声明下面三个方法用于操作计数器，以递增或递减其值：

&lt;ul&gt;
&lt;li&gt;retain     递增保留计数&lt;/li&gt;
&lt;li&gt;release   递减保留计数&lt;/li&gt;
&lt;li&gt;autorelease 待稍后清理 “自动释放池” 时，再递减保留计数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;在调用release 之后，对象所占的内存可能会被回收，这样子在调用对象的方法就可能使程序崩溃，这里 “可能” 的意思是对象所占的内存在 “解除分配” （deallocated）之后，只是放回 “可用内存池”（avaiable pool）。若果执行方法时尚未覆写对象，那么对象仍然有效。&lt;/li&gt;
&lt;li&gt;为避免在不经意间使用无效对象，一般在调用完release 之后都会清空指针，保证不会出现可能指向无效对象的指针，这种指针通常被称为 “悬挂指针”（dangling pointer）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;自动释放池&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;调用release 会立刻递减对象的保留计数（这里可能会令系统回收此对象），调用autorelease 方法，是在稍后递减计数，通常是在下一次 “事件循环” 时递减。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;此特性很有用，尤其是在返回对象时更应该用它&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   - (NSString *)stringValue {
    NSString *str = [[NSString alloc] 
                initWithFormat:@&amp;quot;I am this %@&amp;quot;,self];
    return str;
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;这里返回的str 对象的保留计数会比期望值多1，因为调用alloc 会令保留计数+1，这里又没有对应的释放操作，这样子就意味着调用者要负责处理这多出来的保留操作。在这个方法又不能释放str，否则还没等方法返回，str 这个对象就被释放了。这里应该用autorelease ，它会在稍后释放对象，保证这里可以保证调用者可以先用这个str 对象。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;autorelease 能延长对象声明周期，使其在跨越方法调用边界后依然可以存活一段时间。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;保留环&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;呈环状相互引用的多个对象，相互持有，这将导致内存泄漏，这里循环中的对象其保留计数不会降为0。&lt;/li&gt;
&lt;li&gt;通常采用 “弱引用” 来解决此问题，或者从外界命令某个对象不再保留另外一个对象来打破保留环，从而避免内存泄漏。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其保留计数至少为1。若保留计数为正，则对象继续存活。当保留计数降为0时，对象就被销毁了。&lt;/li&gt;
&lt;li&gt;在对象生命期中，其余对象通过引用来保留或释放此对象。保留与释放操作分别会递增及递减保留计数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 30 条：以 ARC 简化引用计数&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;内存泄漏：没有正确的释放已经不再使用的内存。&lt;/li&gt;
&lt;li&gt;自用引用计数预先加入适当的保留或释放操作来避免内存泄漏，使用ARC 时，引用计数实际上还是要执行的，只是保留与释放操作是由ARC 自动添加的。&lt;/li&gt;
&lt;li&gt;ARC 会自动执行retain、release、autorelease、dealloc等操作，所以在ARC 下调用这些内存管理方法是非法的。因为ARC 会分析何处应该自动调用内存管理方法，所以我们再手动调用的话，会干扰其工作。&lt;/li&gt;
&lt;li&gt;实际上，ARC 在调用这些方法时，并不是普通的Objective-C 消息派发机制，而是直接调用其底层的C 语言函数，这样子性能会更好。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;使用ARC 时必须遵循的方法命名规则&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将内存管理语义在方法名中表示出来，若方法名以下列词语开头，则返回的对象归调用者所有：

&lt;ul&gt;
&lt;li&gt;alloc&lt;/li&gt;
&lt;li&gt;new&lt;/li&gt;
&lt;li&gt;copy&lt;/li&gt;
&lt;li&gt;mutableCopy&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;将内存管理交由编译器和运行期组件来做，可以使代码得到多种优化。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;变量的内存管理语义&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ARC 也会处理局部变量与实例变量的内存管理。&lt;/li&gt;
&lt;li&gt;我们通常会给局部变量加上修饰符来打破 “块”（block）所引入的 “保留环”（retain cycle）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;ARC 如何清理实例变量&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对实例变量进行内存管理，必须在 “回收分配给对象的内存” 时生成必要的清理代码。凡事具备强引用的变量，都必须释放，ARC 会在dealloc 方法中插入这些代码。&lt;/li&gt;
&lt;li&gt;ARC 会借用Objective-C++ 的一项特性来生成清理代码，在回收对象时，待回收对象会调用所有C++ 对象的析构函数，编译器如果发现某个对象里含有C++ 对象，就会生成名为&lt;code&gt;.cxx_desteuct&lt;/code&gt; 的方法，ARC 借助此特性，在该方法中生成清理内存所需的代码。&lt;/li&gt;
&lt;li&gt;对于非Objective-C 的对象，然后需要我们手动清理。&lt;code&gt;CFRelease();&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;覆写内存管理方法&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;非ARC 时可以覆写内存管理方法，在ARC 下禁止覆写内存管理方法，会干扰到ARC 分析对象生命周期的工作。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;有ARC 之后，程序员就无需担心内存管理问题了。使用ARC 来编程，可省去类中的许多 “样板代码”。&lt;/li&gt;
&lt;li&gt;ARC 管理对象生命周期的办法基本上是：在适合的地方插入 “保留” 及 “释放” 操作。在ARC 环境下，变量的内存管理语义可以通过修饰符指明，而原来则需要手工执行 “保留”及 “释放” 操作。&lt;/li&gt;
&lt;li&gt;ARC 只负责管理Objective-C 对象的内存。尤其要注意：CoreFoundation 对象不归ARC 管理，开发者必须适时调用CFRetain/CFRelease。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 31 条：在 dealloc 方法中只释放引用并解除监听&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;对象在经历生命周期后，最终会为系统回收，这时候就要执行dealloc 方法。每个对象生命周期内，此方法只会调用一次，也就是保留计数为0 的时候，绝对不能自己调用dealloc 方法，运行期会在适当的时候调用，一旦调用，对象就不再有效了，后续的方法调用均是无效的。&lt;/li&gt;
&lt;li&gt;dealloc 方法主要是释放对象所拥有的引用，也就是把Objective-C 对象都释放掉，ARC 会通过自动生成的&lt;code&gt;.cxx_desteuct&lt;/code&gt; 方法，在dealloc 中为你自动添加这些释放代码。但是其他非Objective-C 对象就需要自己手动释放了。&lt;/li&gt;
&lt;li&gt;dealloc 方法通常还需要把原来配置过的观测行为都清理掉，例如通知等。&lt;/li&gt;
&lt;li&gt;对于开销较大或者系统内稀缺的资源不应该等到dealloc 才清理（文件描述符、套接字、大块内存等），因为dealloc 并不会在特定的时机调用，因为有可能还有别的对象持有它。应该自己实现一个方法，当应用程序用完资源对象后，就调用此方法，这样子对象的生命周期就更加明确了。&lt;/li&gt;
&lt;li&gt;调用dealloc 方法的那个线程会执行 “最终的释放操作”，令对象保留计数为0，而某些方法必须在特定的线程调用，若在dealloc 中调用那么方法，无法保证当前的线程就是那个方法所需的线程。在dealloc 里尽量不要去调用方法，包括属性的存取方法，因为在这些方法可能会被覆写，并在其中做一些无法在回收阶段安全执行的操作。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在dealloc 方法里，应该做的事情就是释放指向其他对象的引用，并取消原来订阅的 “键值观测”（KVO）或NSNotification 等通知，不要做其他事情。&lt;/li&gt;
&lt;li&gt;如果对象持有文件描述符等系统资源，那么应该专门编写一个方法来释放此种资源。这样的类要和其使用者约定：用完资源后必须调用close 方法。&lt;/li&gt;
&lt;li&gt;执行异步任务的方法不应在dealloc 里调用；只有在正常状态下执行的那些方法也不应在dealloc 里调用，因为此时对象已处于回收的状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 32 条：编写 “异常安全代码” 时留意内存管理问题&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;纯C 中没有异常，C++与Objective-C 都支持异常，在运行期系统中C++与Objective-C 异常相互兼容，也就是说，从其中一门语言里抛出的异常能用另外一门语言所编写的 “异常处理程序” 来捕获。&lt;/li&gt;
&lt;li&gt;Objective-C 错误模型表明，异常只应发生严重错误后抛出，发生异常如何管理内存很重要，在try 块中保留某个对象的，但是在释放它之前抛出异常了，这时候就无法正常释放了，这时候需要借助@finally 块来保证释放对象的代码一定会执行，且只执行一次。&lt;/li&gt;
&lt;li&gt;在ARC 不会自动生成处理异常中的代码，因为这样子需要加入大量的样板代码，以便追踪待清理的对象，从而在抛出异常时将其释放。可以这段代码会严重运行期的性能，还会增加应用程序的大小。&lt;/li&gt;
&lt;li&gt;可以通过&lt;code&gt;-fobjc-arc-exceptions&lt;/code&gt;  这个编译编织来开启这个功能，但是这个功能不应该作为生成这种安全处理异常所用的附加代码，应该是让代码处于Objective-C++模式。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;捕获异常时，一定要注意将try 块内创建的对象清理干净。&lt;/li&gt;
&lt;li&gt;在默认情况下，ARC 不生成安全处理异常所需的清理代码。开启编译标志后，可生成这种代码，不过会导致应用程序变大，而且会降低运行效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 33 条：以弱引用避免保留环&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt; 几个对象都已某种方式互相引用，从而形成 “环”，这种情况通常会泄漏内存，因为没有东西引用环中对象，这样子环里的对象互相引用，不会被系统回收。&lt;/li&gt;
&lt;li&gt;避免保留环的最佳方式就是弱引用，来表示 “非拥有关系”，unsafe_unretained、weak 修饰都是可以达到的。unsafe_unretained 表示属性值可能不安全，有可能系统把属性所指的对象回收了，但是这个属性依然指向那块地址，那么再调用它的方法可能会使程序崩溃，用weak 修饰的时候，在所指对象被回收的时候，会将属性的指针置为nil。&lt;/li&gt;
&lt;li&gt;一般来说，如果不拥有某对象，就不要保留它，这条规则对collection 例外，collection 虽然不直接拥有其内容，但是它要代表自己所属的那个对象来保留这些元素。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;将某些引用设为weak，可避免出现 “保留环”。&lt;/li&gt;
&lt;li&gt;weak 引用可以自动清空，也可以不自动清空。自动清空是随着ARC 而引入的新特性，由运行期系统来实现。在具备自动清空功能的弱引用上，可以随意读取其数据，因为这种引用不会指向已经回收过的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 34 条：以 “自动释放池块” 降低内存峰值&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;释放对象有两种方式：&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;一种是调用release 方法，使其保留计数立即递减&lt;/li&gt;
&lt;li&gt;一种是调用autorelease 方法，将对象放入 “自动释放池” 中，自动释放池用于存放那些需要稍后某个时刻释放的对象，清空（drain）自动释放池时，系统会向其中的对象发送release 消息。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;创建自动释放池，系统会自动创建一些线程，这些线程默认都有自动释放池，每次执行 “事件循环”时，都会将其清空。自动释放池于左边花括号创建，并于对应的右花括号自动清空。位于自动释放池范围内的对象，会在末尾处受到release 消息。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   @autoreleasepool {
   //...
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;内存峰值：是指应用程序在某个特定时段内的最大内存用量。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对象有可能会放在自动释放池里面，需要等到线程执行下一次事件循环才会清空，这里会导致应用程序所占内存会持续增加，等到临时对象释放的时候，内存用量又会突然下降。我们现在就想把这个内存峰值给降低下来。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以增加一个自动释放池来解决这个问题：这样子对象就会加入到这个释放池，而不是线程的主池中，每次循环都创建和释放这个释放池。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   for (int i = 0;i &amp;lt; 100000;i++){
    @autorelease{
        NSObject *object = [NSObject new];
    }
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;自动释放池机制就像 “栈” 一样。系统创建好自动释放池之后，就将其推入栈中，而清空自动释放池，则相当于将其从栈中弹出。在对象上执行自动释放操作，就等于将其放入栈顶的那个池。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于是否需要用池来优化效率，这个得考虑清楚来，因为自动释放池的创建还是有一丢丢开销的，所以尽量不要建立额外的自动释放池。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;自动释放池排布在栈中，对象收到autorelease 消息后，系统将其放入到最顶端的池里。&lt;/li&gt;
&lt;li&gt;合理运用自动释放池，可降低应用程序的内存峰值。&lt;/li&gt;
&lt;li&gt;@autoreleasepool 这种新式写法能创建出更为轻便的自动释放池。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 35 条：用 “僵尸对象” 调试内存管理问题&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;向已回收的对象发送消息是不安全的，是否崩溃这个是看对象所占的内存有没有为其他内容所覆写。&lt;/li&gt;
&lt;li&gt;Cocoa 提供 “僵尸对象”（Zombie Object）这个非常方便的功能，开启后，运行期系统会把已经回收的实例转换成特殊的 “僵尸对象”，而不会真正回收它们。这个对象所在的核心内无法重用，因此不可能遭到覆写，僵尸对象收到消息后，会抛出异常。&lt;/li&gt;
&lt;li&gt;使用：Xcode Scheme 中的Enable Zombie Objects 选项，打开会将NSZombieEnabled 环境变量设成YES。&lt;/li&gt;
&lt;li&gt;系统在即将回收时，会执行一个附加步骤，将对象转换成僵尸对象，而不彻底回收。僵尸类是从名为_NSZombie_ 的模版类复制出来的。_NSZombie_ 类并未实现任何方法，此类没有超类，因此跟NSObject 一样，也是一个 &amp;quot;根类&amp;quot;，该类只有一个实例变量，叫做isa，所以发给他的消息都要经过 “完整的消息转发机制” 。&lt;/li&gt;
&lt;li&gt;在完整的消息转发机制中，&lt;code&gt;___forwarding___&lt;/code&gt;  是核心，检查接受消息的对象所属的类名，若是_NSZombie_ ，则表示消息接受者是僵尸对象，需要特殊处理。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;系统在回收对象时，可以不将其真的回收，而是把它转化成僵尸对象。通过环境变量NSZombieEnabled 可开启此功能。&lt;/li&gt;
&lt;li&gt;系统会修改对象的isa 指针，令其指向特殊的僵尸类，从而使该对象变成僵尸对象。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容及其接受者的消息，然后终止应用程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 36 条：不要使用 retainCount&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;每个对象都有一个计数器，其表明还有多少个其他对象想令此对象继续存活。在ARC &lt;code&gt;retainCount&lt;/code&gt; 这个方法已经废弃了，但是在非ARC 中也不应该调用这个方法，因为这个保留计数只是返回某个时间点的值，并不会联系上下文给出真正有用的值。&lt;/li&gt;
&lt;li&gt;retainCount 可能永远不返回0，因为系统有时候会优化对象的释放行为，在保留计数为1的时候就把它回收了。&lt;/li&gt;
&lt;li&gt;不应该依靠保留计数的具体址来编码。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;对象的保留计数看似有用，实则不然，因为任何给定时间点上的 “绝对保留计数”（absolute retain count）都无法反映对象生命期的全貌。&lt;/li&gt;
&lt;li&gt;引入ARC 之后，retainCount 方式就正式废止了，在ARC 下调用方法会导致编译器报错。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 23 May 2017 00:00:00 +0800</pubDate>
        <link>http://pengxuyuan.github.io/2017/05/Effective-Objective-C-2.0-five/</link>
        <guid isPermaLink="true">http://pengxuyuan.github.io/2017/05/Effective-Objective-C-2.0-five/</guid>
        
        
      </item>
    
      <item>
        <title>Effective Objective-C 2.0 总结（四）</title>
        <description>&lt;h2&gt;协议与分类&lt;/h2&gt;

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h3&gt;第 23 条：通过委托与数据源协议进行对象间通信&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Objective-C 可以使用 “委托模式”（Delegate pattern）的编程设计模式来实现对象间的通信：定义一套接口，某对象若想接受另一个对象的委托，则需遵从此接口，以便成为其 “委托对象”（delegate）。Objective-C 一般利用 “协议” 机制来实现此模式。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;定义协议：&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   @protocol EOCNetworkingFetcherDelegate
   @optional
   - (void)newworkingFetcher:(EOCNetworkingFetcher *)fetcher
               didRecevieData:(NSData *)data;
   - (void)newworkingFetcher:(EOCNetworkingFetcher *)fetcher
            didFailWithError:(NSError *)error;
   @end

   @interface EOCNetworkingFetcher : NSObject
   @property (nonatomic,weak) id&amp;lt;EOCNetworkingFetcherDelegate&amp;gt; delegate;
   @end
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;委托协议名通常时在相关的类名加上Delegate 一词，也是采用 “驼峰法” 来命名。&lt;/li&gt;
&lt;li&gt;类可以用一个属性存放其委托对象，属性要用weak 来修饰，避免产生 “保留环”（retain cycle）。&lt;/li&gt;
&lt;li&gt;某类若要遵从某委托协议，可以在其接口中声明，也可以在&amp;quot;class-continuation 分类&amp;quot; 中声明，如果要向外界公布此类实现了某协议，就在接口中声明，如果这个协议是个委托协议，通常只会在这个类的内部使用，这样子就在分类中声明就好了。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;如果要在委托对象上调用可选方法，那么必须提前使用类型信息查询方法，判断这个委托对象能否响应相关的选择子。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   NSData *data;
   if([_delegate respondsToSelector:@selector(networkFetcher:didRecevieData:)]){
    [_delegate networkFetcher:self didRecevieData:data];
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;在调用delegate 对象中的方法时，总应该把发起委托的实例也一并传入方法中，这样子，delegate 对象在实现相关方法时，就能根据传入的实例分别执行不同的代码了。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;delegate 里的方法也可以用于从委托对象中获取信息（数据源模式）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在实现委托模式和数据源模式的时，协议中的方法是可选的，我们就会写出大量这种判断代码：&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   if([_delegate respondsToSelector:@selector(networkFetcher:didRecevieData:)]){
    [_delegate networkFetcher:self didRecevieData:data];
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;每次调用方法都会判断一次，其实除了第一次检测的结构有用，后续的检测很有可能都是多余的，因为委托对象本身没变，不太可能会一下子不响应，一下子响应的，所以我们这里可以把这个委托对象能否响应某个协议方法记录下来，以优化程序效率。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将方法响应能力缓存起来的最佳途径是使用 “位段”（bitfield）数据类型。我们可以把结构体中某个字段所占用的二进制位个数设为特定的值。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;位段，C语言允许在一个结构体中以位为单位来指定其成员所占内存长度，这种以位为单位的成员称为“位段”或称“位域”( bit field) 。&lt;/p&gt;

&lt;p&gt;struct data {&lt;/p&gt;

&lt;p&gt;​  unsigned int filedA : 8;&lt;/p&gt;

&lt;p&gt;​  unsigned int filedB : 4;&lt;/p&gt;

&lt;p&gt;​  unsigned int filedC : 2;&lt;/p&gt;

&lt;p&gt;​  unsigned int filedD : 1;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;filedA 位段占用8个二进制位，filedB 位段占用4个二进制位，filedC 位段占用2个二进制位，filedD位段占用1个二进制位。filedA 就可以表示0至255之间的值，而filedD 则可以表示0或1这两个值。&lt;/p&gt;

&lt;p&gt;我们可以像filedD 这样子，创建大小只有1的位段，这样子就可以把Boolean 值塞入这一小块数据里面，这里很适合这样子做。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;利用位段就可以清楚的表示delegate 对象是否能响应协议中的方法。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt; @interface EOCNetworkingFetcher ()
 struct {
    unsigned int didReceiveData : 1;
    unsigned int didFailWithError : 1;
    unsigned int didUpdateProgressTo : 1;
 } _delegateFlags
 @end

 //使用
 //set flag
 _delageteFlags.didReceiveData = 1;

 //check flag
 if(_delageteFlags.didReceiveData){
    //YES
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以在delegate 属性的设置方法里面写实现缓存功能所用的代码。 &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这样子，每次调用delegate 的相关方法之前，就不用检测委托对象是否能响应给定的选择子了，而是直接查询结构体里面的标志。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在相关方法需要调用很多次时，就要思考是否有必要进行优化，分析代码性能，找出瓶颈，使用这个位段这个技术可以提供执行速度。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;委托模式为对象提供了一套接口，使其可由此将相关事件告知其他对象。&lt;/li&gt;
&lt;li&gt;将委托对象应该支持的接口定义成协议，在协议中把可能需要处理的事件定义成方法。&lt;/li&gt;
&lt;li&gt;当某对象需要从另外一个对象中获取数据时，可以使用委托模式。这种情境下，该模式亦称 “数据源协议”（data source protocal）。&lt;/li&gt;
&lt;li&gt;若有必要，可实现含有位段的结构体，将委托对象是否能响应相关协议方法这一信息缓存至其中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 24 条：将类的实现代码分散到便于管理的数个分类之中&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;一个类经常有很多方法，尽管代码写的比较规范，这个文件还是会越来越大，定位问题以及阅读上都会造成不便。我们可以通过 “分类” 机制来把代码按逻辑划分到几个分区中。&lt;/li&gt;
&lt;li&gt;通过分类机制，可以把类代码分成很多个易于管理的小块，以便单独检视。&lt;/li&gt;
&lt;li&gt;可以考虑创建Private 分类，将一些不是公共API 的方法，隐藏起来。写程序库的时候，加上不暴露头文件，使用者就不知道库里还有这些私有方法。 &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt; 使用分类机制把类的实现代码划分成易于管理的小块。&lt;/li&gt;
&lt;li&gt; 将应该视为 “私有” 的方法归入为叫Private 的分类中，以隐藏实现细节。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 25 条：总是为第三方类的分类名称加前缀&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;分类机制常用于向无源码的既有类中新增新功能，但是在使用的时候要十分小心，不然很容易产生Bug。因为这个机制时在运行期系统加载分类时，将其方法直接加到原类中，这里要注意方法重名的问题，不然会覆盖原类中的同名方法。&lt;/li&gt;
&lt;li&gt;一般用前缀来区分各个分类的名称与其中所定义的方法。&lt;/li&gt;
&lt;li&gt;不要轻易去利用分类来覆盖方法，这里需要慎重考虑。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;向第三方类中添加分类时，总应该给其名称加上你专用的前缀。&lt;/li&gt;
&lt;li&gt;向第三方类中添加分类时，总应给其中的方法名加上你专用的前缀&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 26 条：勿在分类中声明属性&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;可以利用运行期的关联对象机制，为分类声明属性，但是这种做法要尽量避免，因为除了 &amp;quot;class-continuation 分类&amp;quot; 之外，其他分类都无法向类中新增实例变量，因此，他们无法把实现属性所需的实例变量合成出来。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在分类定义属性的时候，会报警告，表明此分类无法合成该属性相关的实例变量，所以开发者需要在分类中为该属性实现存取方法。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;利用关联对象机制可以解决分类中不能合成实例变量的问题。自己实现存取方法，但是要注意该属性的内存管理语义（属性特质）。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   @property (nonatomic,copy) NSString *name;

   static const void *kViewControllerName = &amp;amp;kViewControllerName;

   - (void)setName:(NSString *)name {
       objc_setAssociatedObject(self, kViewControllerName, name, OBJC_ASSOCIATION_COPY_NONATOMIC);
   }

   - (NSString *)name {
       NSString *myName = objc_getAssociatedObject(self, kViewControllerName);
       return myName;
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在可以修改源代码的情况下，尽量把属性定义在主接口中，这里是唯一能够定义实例变量的地方，属性只是定义实例变量及相关存取方法所用的 “语法糖”。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;由于实现属性所需的全部方法都已实现，所以不会再为该属性自动合成实例变量了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;尽量把封装数据所用的全部属性都定义在主接口里。&lt;/li&gt;
&lt;li&gt;在 “class-continuation 分类” 之外的其他分类中，可以定义存取方法，但尽量不要定义属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 27 条：使用 ”class-continuation 分类“ 隐藏实现细节&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;”class-continuation 分类“ 必须定义在本身类的实现文件中，而且这里是唯一可以声明实例变量的分类，而且此分类没有特定的实现文件，这个分类也没有名字。这里可以定义实例变量的原因是 “ 稳固的ABI” 机制，我们无须知道对象的大小就可以直接使用它。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   @interface EOCPerson ()

   @end
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;可以将不需要要暴露给外界知道的实例变量及方法写在 “class-continuation 分类” 中。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;编写Objective-C++ 代码时候，使用 “class-continuation 分类” 会十分方便。因为对于引用了C++的文件的实现文件需要用.mm 为扩展名，表示编译器应该将此文件按照Objective-C++ 来编译。C++ 类必须完全引入，编译器要完整地解析其定义才能得知这个C++ 对象的实例变量大小。如果把对C++ 类的引用写在头文件的话，其他引用到这个类也会引用到这个C++ 类，就也需要编译成Objective-C++ 才行，这样子很容易失控。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里可以利用 “class-continuation 分类” 把引用C++ 类的细节写到实现文件中，这样子别的类引用这个类就不会受到影响，甚至都不知道这个类底层实现混有C++ 代码。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用 “class-continuation 分类” 还可以将头文件声明 “只读” 的属性扩展成 “可读写”，以便在类的内部可以设置其值。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我们通常不直接访问实例变量，而是通过设置方法来做，因为这样子可以触发 “键值观测” （Key-Value Observing，KVO）通知。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;若对象所遵循的协议只应视为私有，也可以同过“class-continuation 分类” 来隐藏。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;通过 “class-continuation 分类” 向类中新增实例变量。&lt;/li&gt;
&lt;li&gt;如果某属性在主接口中声明为 “只读”，而类的内部又要用设置方法修改此属性，那么就在 “class-continuation 分类” 中将其扩展为 “可读写”。&lt;/li&gt;
&lt;li&gt;把私有方法的原型声明在 “class-contiunation 分类” 里面。&lt;/li&gt;
&lt;li&gt;若想使类所遵循的协议不为人所知，则可于 “class-contiunation 分类” 中声明。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 28 条：通过协议提供匿名对象&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;objective-c
@property (nonatomic,weak) id&amp;lt;EOCDelegate&amp;gt; delegate;
&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;该属性类型是id&amp;lt;EOCDelegate&amp;gt; 的，所以实际上任何类的都能充当这一属性，即便该类不继承NSObject 也可以，只要遵循EOCDelegae 协议就可以了，对于具备此属性的类来说，delegate 就是 “匿名的”。&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;协议可在某种程度上提供匿名类型。具体的对象类型可以淡化成遵从某协议的id 类型，协议里规定了对象所应实现的方法。&lt;/li&gt;
&lt;li&gt;使用匿名对象来隐藏类型名称（或类名）。&lt;/li&gt;
&lt;li&gt;如果具体类型不重要，重要的是对象能够响应（定义在协议里的）特定方法，那么可使用匿名对象来表示。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 17 May 2017 00:00:00 +0800</pubDate>
        <link>http://pengxuyuan.github.io/2017/05/Effective-Objective-C-2.0-four/</link>
        <guid isPermaLink="true">http://pengxuyuan.github.io/2017/05/Effective-Objective-C-2.0-four/</guid>
        
        
      </item>
    
      <item>
        <title>Effective Objective-C 2.0 总结（三）</title>
        <description>&lt;h2&gt;接口与 API 设计&lt;/h2&gt;

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h3&gt;第 15 条：用前缀避免命名空间冲突&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;如果发生命名冲突（naming clash），那么应用程序的链接过程就会出错，因为出现了重复符号。&lt;/li&gt;
&lt;li&gt;应该为所有名称都加上适当的前缀，最好是三个字母以上做前缀，因为苹果宣称其保留使用所有 “两字母前缀”。&lt;/li&gt;
&lt;li&gt;在类的实现文件所有的纯C 函数及全局变量，也是容易命名冲突的，在编译好的目标文件中，这些要算做 “顶级符号”（top-level symbol）。&lt;/li&gt;
&lt;li&gt;如果自己的代码准备再发布为程序供他人开发应用程序所用，自己的代码以及自己引用到的第三方库都是要加前缀的，避免在未来冲突。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;选择与你的公司、应用程序或两者皆有关联之名称作为类名的前缀，并在所有代码中均使用这一前缀。&lt;/li&gt;
&lt;li&gt;若自己所开发的程序库中用到了第三方库，则应为其中的名称加上前缀。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 16 条：提供 “全能初始化方法”&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;“全能初始化方法”（designated initializer）：为对象提供必要信息以便其能完成工作的初始化方法。&lt;/li&gt;
&lt;li&gt;每个子类的全能初始化方法都应该调用其超类的对应方法，并逐层向上。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在类中提供一个全能初始化方法，并于文档里指明。其他初始化方法均应调用此方法。&lt;/li&gt;
&lt;li&gt;若全能初始化方法与超类不同，则需覆写超类中的对应方法。&lt;/li&gt;
&lt;li&gt;如果超类的初始化方法不适用于子类，那么应该覆写这个超类方法，并在其中抛出异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 17 条：实现 description 方法&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;在调用&lt;code&gt;NSLog(@&amp;quot;object = %@&amp;quot;,onbject);&lt;/code&gt; 其实是调用了对象的description 方法。&lt;/li&gt;
&lt;li&gt;在我们自定义类中，这样子打印输出信息有可能是这种&lt;code&gt;object = &amp;lt;EOCPerson: 0x7hh9j22238800&amp;gt;&lt;/code&gt;  ，这个我们需要重写description 方法，让它返回我们需要的一些信息。&lt;/li&gt;
&lt;li&gt;description 定义在NSObject 协议里面，因为NSObject 不是唯一的 “根类”，用继承不能很好的让其他类有这个方法，例如：NSProxy 也是遵从了NSObject 协议的 “根类”。&lt;/li&gt;
&lt;li&gt;小技巧：可以在description 中用NSDictionary 的description 方法来输出，就是将信息用字典的形式来展示，这样子更加直观，也更加容易扩展。&lt;/li&gt;
&lt;li&gt;debugDescription 方法是开发者在调试器中以控制台命令打印对象时才调用的，默认是直接调用description 方法。&lt;code&gt;po object;&lt;/code&gt; &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;实现 description 方法返回一个有意义的字符串，用以描述该实例。&lt;/li&gt;
&lt;li&gt;若想在调试时打印出更详尽的对象描述信息，则应实现debugDescription 方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 18 条：尽量使用不可变对象&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;设计类的时候，用属性来封装数据，在用属性的时候，可将其声明为 “只读” ，避免外部不必要的修改（PS：如果把可变对象放到collection 之后又修改其内容，很容易会破坏set 的内部数据结构，使其失去固有的语义）。&lt;/li&gt;
&lt;li&gt;尽量把对外公布出来的属性设为只读，而且只在确有必要时才将属性对外公布。&lt;/li&gt;
&lt;li&gt;当我们想外部暴露只读属性、内部需要修改属性，这样子通常是在内部将readonly 属性重新声明为readwrite。但是如果该属性是nonatomic 的，这样子做可能会产生 “竞争条件”（rece condition）。在对象内部写入某属性时，对象外的观察者也许正在读取该属性。若想避免此问题，我们可以在必要时通过 “派发队列”（dispatch queue）等手段，将所有的数据存取操作都设为同步操作。&lt;/li&gt;
&lt;li&gt;虽然属性对外设置成readonly 了，但是外部仍能通过 “键值编码”（Key-Value Coding，KVC）技术设置这些属性值。&lt;code&gt;[object setValue:@&amp;quot;abc&amp;quot; forKey:@&amp;quot;name&amp;quot;]&lt;/code&gt; ，这样子可以修改name 这个属性，KVC 会在类中查找 “setName：” 方法来修改属性值。&lt;/li&gt;
&lt;li&gt;还可以通过类型信息查询功能，查出属性所对应的实例变量在内存中的偏移量，从此来人为设置这个实例变量的值。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;尽量创建不可变的对象。&lt;/li&gt;
&lt;li&gt;若某属性仅可于对象内部修改，则在 “class-continuation 分类” 中将其由readonly 属性扩展成readwrite 属性。&lt;/li&gt;
&lt;li&gt;不要把可变的collection 作为属性公开，而应提供相关方法，以此修改对象中的可变collection。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 19 条：使用清晰而协调的命名方式&lt;/h3&gt;

&lt;p&gt;方法和变量名使用 “驼峰式大小写命名法”：以小写字母开头，其后每个单词首字母大写。类名也采用驼峰式命名法，不过其首字母需要大写，通常还会加两三个前缀字母。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方法命名&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;- (id)initWithWidth:(float)width andHeight:(float)height;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;把方法名起的稍微长一点，可以保证其能准确传达出方法所执行的任务，但是也不能累赘，尽量言简意赅。&lt;/li&gt;
&lt;li&gt;清晰的方法名从左至右读起来好似一篇文章，易于维护，他人也更加易懂。&lt;/li&gt;
&lt;li&gt;NSString 这个类就展示了一套良好的命名习惯，可以去查看下头文件。&lt;/li&gt;
&lt;li&gt;给方法命名总结：

&lt;ul&gt;
&lt;li&gt;如果方法的返回值是新创建的，那么方法名的首个词应该是返回值的类型，除非前面还有修饰语，例如localizedString。属性的存取方法不遵循这种命名方式，因为一般认为这些方法不会创建新对象，即便有时返回内部对象的一份拷贝，我们也认为那相当于原有的对象。这些存取方法应该按照其所对应的属性来命名。&lt;/li&gt;
&lt;li&gt;应该把表示参数类型的名词放在参数前面。&lt;/li&gt;
&lt;li&gt;如果方法要在当前对象上执行操作，那么就应该包含动词；若执行操作时还需要参数，则应该在动词后面加上一个或多个名字。&lt;/li&gt;
&lt;li&gt;不要使用str 这种简称，应该使用string 这样的全称。&lt;/li&gt;
&lt;li&gt;Boolean 属性应加is 前缀。如果某方法返回非属性的Boolean 值，那么应该根据其功能，选用has 或is 当前缀。&lt;/li&gt;
&lt;li&gt;将get 这个前缀留给那些借由 ”输出参数“ 来保存返回值的方法，比如说，把返回值填充到 ”C语言式数组“ 里的那种方法就可以使用这个词做前缀。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;类与协议的命名&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;应该为类与协议的名称加上前缀，以避免命名空间冲突。&lt;/li&gt;
&lt;li&gt;命名应该协调一致，从其他框架继承子类，务必遵循其命名惯例。UIView 子类末尾必须是View，委托协议末尾必须是Delegate。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;起名时应遵从标准的Objective-C 命名规范，这样子创建出来的接口更容易为开发者所理解。&lt;/li&gt;
&lt;li&gt;方法名要言简意赅，从左至右读起来要像个日常用语中的句子才好。&lt;/li&gt;
&lt;li&gt;方法名里不要使用缩略后的类型名称。&lt;/li&gt;
&lt;li&gt;给方法起名时第一要务就是确保其风格与你自己的代码或所有集成的框架相符。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 20 条：为私有方法名加前缀&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;便于区分公共方法跟私有方法。&lt;/li&gt;
&lt;li&gt;前缀根据个人喜好定，目前发现很多第三方库也很少使用这个私有方法名加前缀，这个就看个人喜好吧。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;给私有方法的名称加上前缀，这样可以很容易地将其同公共方法区分开。&lt;/li&gt;
&lt;li&gt;不要单用一个下划线做私有方法的前缀，因为这种做法是预留给苹果公司用的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 21 条：理解Objective-C 错误模型&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;ARC 默认不是 “异常安全的”，如果抛出异常，那么应在作用域末尾释放的对象现在却不会自动释放了。想要生成 “异常安全的” 代码，可以设置编译器的标志来实现 “-fobjc-arc-exceptions”。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;平常很难写出在抛出异常时不会导致内存泄漏的代码，Objective-C 语言现在采用的办法是：只在极其罕见的情况下抛出异常，抛出异常应用程序直接退出，不考虑修复问题，不用再写复杂的 “异常安全” 代码。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在 “不那么严重的错误”，令方法返回nil/0,或者是使用NSError，表明其中有错误发生。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NSError 可以经由此对象，把导致错误的原因回报给调用者。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;Error domain 错误范围，其类型为字符串&lt;/li&gt;
&lt;li&gt;Error code 错误码，其类型为整数&lt;/li&gt;
&lt;li&gt;User info 用户信息，其类型为字典&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;第一种常见用法是：通过委托协议来传递此错误&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;     - (void) connection:(NSURLConnection *)connection
         didFailWithError:(NSError *)error;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;另外一种常见的方法是：经由方法的 “输出参数” 返回给调用者&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   //定义
   - (BOOL) doSomething:(NSError **)error;

   //用法
   NSError *error = nil;
   BOOL ret = [objecr doSomething:&amp;amp;error]
   if(ret){
    //to do
   }

   //具体实现
   - (BOOL) doSomething:(NSError **)error {
     if(/*there was an error*/){
      if(error){
            *error = [NSError errorWithDomain:domain
                                     code:code
                                 userInfo:userInfo];
            return NO;
        }
     }else{
        return YES;
     }
   }

   //这个*error 语法会为error 参数“解引用”（dereference），也就是说，error 所指的那个指针现在要指向新的NSError 对象，所以这里要确保error 参数不是nil。
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;传递给方法的参数是个指针，而该指针的又指向另外一个指针，那个指针指向NSError 对象（指向NSError 对象的指针）。这样子，此方法不仅能有普通的返回值，还可以经由 “输出参数” 把NSError 对象回传给调用者。    &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用ARC 时，编译器会吧NSError** 转换成NSError * _ _autorelease*， 也就是说指针所指的对象会在方法执行完毕后自动释放。这个对象必须自动释放，因为 “doSomething：” 方法不能保证调用者可以把此方法中创建的NSError 释放掉，所以必须加入autorelease。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;只有发生了可使整个应用程序崩溃的严重错误时，才应使用异常。&lt;/li&gt;
&lt;li&gt;在错误不那么严重的情况下，可以指派 “委托方法”（delegate method）来处理错误，也可以把错误信息放在NSError 对象里，经由 “输出参数” 返回给调用者。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 22 条：理解NSCopying 协议&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;使用对象经常需要拷贝它，此操作通过copy 方法完成。如果想令自己的类支持拷贝操作，那就实现NSCopying 协议，该协议只有一个方法：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   - (id)copyWithZone:(NSZone *)zone
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;以前开发程序，会把内存分成不同的 “区”（zone），而对象会创建在不同区里面，现在不用了，每个程序只有一个区：“默认区”（default zone）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NSMutableCopying 协议跟NSCopying 类似，也只有一个方法：&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   - (id)mutableCopyWithZone:(NSZone *)zone 
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果你的类分可变版本与不可变版本，这两个协议你都应该实现。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注意：在可变对象上调用copy 方法返回另外一个不可变类的实例。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在编写拷贝方法时，还要确定一个问题：应该执行 “深拷贝”（deep copy）还是 “浅拷贝”（shallow copy）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;深拷贝是指在拷贝对象自身时，将其底层的数据也一并复制过去；浅拷贝只对拷贝对象的指针，并不会拷贝底层的数据。Foundation 框架中的所有collection 类默认都执行浅拷贝。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;没有专门定义深拷贝的协议，所以具体执行方式由每个类来确定。另外不要假设遵从了NSCopying 协议的对象都会执行深拷贝。绝大多数情况下，执行的都是浅拷贝。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;若想令自己所写的对象具备拷贝功能，则需实现NSCopying 协议。&lt;/li&gt;
&lt;li&gt;如果自定义的对象分为可变版本与不可变版本，那么就要同时实现NSCopying 与 NSMutableCopying 协议。&lt;/li&gt;
&lt;li&gt;复制对象时需决定采用浅拷贝还是深拷贝，一般情况下应该尽量执行浅拷贝。&lt;/li&gt;
&lt;li&gt;如果你所写的对象需要深拷贝，那么可以考虑新增一个专门执行深拷贝的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 17 May 2017 00:00:00 +0800</pubDate>
        <link>http://pengxuyuan.github.io/2017/05/Effective-Objective-C-2.0-three/</link>
        <guid isPermaLink="true">http://pengxuyuan.github.io/2017/05/Effective-Objective-C-2.0-three/</guid>
        
        
      </item>
    
      <item>
        <title>Effective Objective-C 2.0 总结（二）</title>
        <description>&lt;h2&gt;对象、消息、运行期&lt;/h2&gt;

&lt;h3&gt;第 6 条：理解 “属性” 这一概念&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;“对象”（object）就是 “基本构造单元”（building block），开发者可以通过对象来存储并传递数据，在对象直接传递数据并执行任务的过程就叫做 “消息传递”（Messaging）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果对象布局在编译器就固定了，访问变量时，编译器会使用 “偏移量”（offset）来计算，这个偏移量是 “硬编码”（hardcode），表示该变量距离存放对象的内存区域的起始地址有多远。 存在一个问题：如果代码使用了编译期计算出来的偏移量，那么修改类定义之后必须重新编译，否则就会出错。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Objective-C 处理方式是：把实例变量当作一种存储偏移量所用的 “特殊变量”（speacial variable），交由 “类对象”（class object）保管。偏移量会在运行期查找，这样子总能找到正确的偏移量，这就是稳固的 “应用程序二进制接口”（Application Binary Interface，ABI）。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用 “点语法” 的效果与直接调用存取方法相同，没有丝毫差别。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;属性有很多优势：&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可以使用 “点语法”&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;编译器会自动编写访问这些属性所需的方法，此过程就做 “自动合成”（autosynthesis）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;编译器还会自动向类添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在实现代码中可以通过@synthesize 语法来指定实例变量的名字&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt; @implementation EOCPerson
 @synthesize firstName = _myFirstName;
 @synthesize lastName = _myLastName;
 @end
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@dynamic 关键字会告诉编译器：不要自动创建实现属性所用的实例变量，也不要为其创建存取方法&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;属性特质&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;属性可以拥有的特质分类四类：原子性、读/写权限、内存管理语义、方法名&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原子性（atomicity）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;属性默认情况下编译器所合成的方法会通过锁定机制确保其原子性，用nonatomic 特质，就不使用同步锁。&lt;/p&gt;

&lt;p&gt;iOS 使用同步锁的开销较大，这会带来性能问题，一般情况下并不要求属性必须是 “原子的”，因为 “原子性” 并不能保证 “线程安全”（thread safety），若要实现 “线程安全” 的操作，还需采用更加深层的锁定机制才行。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;读／写权限&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;具备readwrite（读写）特质的属性拥有 “获取方法”（getter）与 “设置方法”（setter）。若该属性由@synthesize 实现，则编译器会自动生成这两个方法。&lt;/li&gt;
&lt;li&gt;具备readonly（只读）特质的属性仅拥有获取方法，只有该属性由@synthesize 实现，编译器才会为其合成获取方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;内存管理语义&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;assign&lt;/li&gt;
&lt;li&gt;strong&lt;/li&gt;
&lt;li&gt;weak&lt;/li&gt;
&lt;li&gt;unsafe_unretained&lt;/li&gt;
&lt;li&gt;copy&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;方法名&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以指定存取的方法名。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   @property (nonatomic,getter = isOn) BOOL on;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;可以用@property 语法来定义对象中所封装的数据。&lt;/li&gt;
&lt;li&gt;通过 “特质” 来指定存储数据所需的正确语义&lt;/li&gt;
&lt;li&gt;在设置属性所对应的实例变量时，一定要遵从该属性所声明的语义。&lt;/li&gt;
&lt;li&gt;开发iOS 程序时应该使用nonatomic 属性，因为atomic 属性会严重影响性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 7 条：在对象内部尽量直接访问实例变量&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;强烈建议：读取实例变量的时候采用直接访问的形式，而在设置实例变量的时候通过属性来做。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关于直接访问跟通过属性访问的区别：&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;由于不经过Objective-C 的 “方法派发” 步骤，所以直接访问实例变量的速度当然比较快。在这种情况下，编译器所生成的代码会直接访问保存对象实例变量的那块内存。&lt;/li&gt;
&lt;li&gt;直接访问实例变量时，不会调用其 ”设置方法“，这就绕过了为相关属性所定义的 ”内存管理语义“。比方说，如果在ARC 下直接访问一个声明为copy 的属性，那么并不会拷贝改属性，只会保留新值并释放旧值。&lt;/li&gt;
&lt;li&gt;如果直接访问实例变量，那么不会触发 ”键值观测“（Key-Value Observing，KVO）通知。&lt;/li&gt;
&lt;li&gt;通过属性来访问有助于排查与之相关的错误，因为可以给 ”获取方法“ 或 ”设置方法“ 中新增断点，进行调试。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在初始化方法中总是应该直接访问实例变量，避免子类重写了设置方法（处理异常情况抛出异常）但是：如果待初始化的实例声明在超类中，而我们又无法在子类直接访问此实例变量的话，那么就需要调用 “设置方法” 了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在 “惰性初始化”（lazy initialization），必须通过 “获取方法” 来访问属性，不然实例变量永远不会初始化。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在对象内部读取数据时，应该直接通过实例变量来读，而写入数据时，则应通过属性来写。&lt;/li&gt;
&lt;li&gt;在初始化方法及dealloc 方法中，总是应该直接通过实例变量来读写数据。&lt;/li&gt;
&lt;li&gt;有时会使用惰性初始化技术配置某份数据，在这种情况下，需要通过属性来读取数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 8 条：理解 “对象等同性” 这一概念&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;使用 == 操作符比较的两个指针的本身，而不是其所指的对象；所以这里有可能会出轨，得不到我们想要的结果。NSObject 提供 “isEqual” 方法，某些对象也提供了特殊的 “等同性判定方法”&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   NSString *foo =@&amp;quot;Badger 123&amp;quot;;
   NSString *bar = [NSString stringWithFormat:@&amp;quot;Badger %i&amp;quot;,123];
   BOOL equalA = (foo == bar);  //equalA = NO
   BOOL equalB = [foo isEqual:bar]; //equalB = YES
   BOOL equalC = [foo isEqualToString:bar]; //equalC = YES
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;NSObject 协议中有两个用于判断等同性的关键方法：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   - (BOOL)isEqual:(id)object;
   - (NSUInteger)hash;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;如果 “isEqual” 方法判定两个对象相等，那么其hash 方法也必须返回同一个值。但是，如果两个对象的hash 方法返回同一个值，那么 “isEqual” 方法未必会认为两者相等。&lt;/p&gt;

&lt;p&gt;对于实现hash 方法需要一些技巧：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   - (NSUInteger)hash {
    return 1337;
   }
   //这样子是可以的，但是会对collection 使用这个对象产生性能问题。因为在collection 在检索哈希表的时，会用对象的哈希码来做索引，在set 集合中，会根据哈希码把对象分装到不同的数组里面，在添加新对象的时候，要根据其哈希码找对与之对应的数组，依次检查其中各个元素，看数组已有的对象是否和将要添加的新对象相等，如果相等，就说明添加的对象已经在set 集合中了，是添加失败的。（如果所有对象的hash 值对一样，这样子set 集合只会有一个数组，所有数据都在一起了，每次插入数据都会遍历这个数组，这样子就会出现性能问题）

   - (NSUInteger)hash {
    NSString *stringToHash = [NSString stringWithFormat@&amp;quot;%@:%@&amp;quot;,_firstName,_lastNmae];
    return [stringToHash hash];
   }
   //这样子能保证返回不同的哈希码，但是这里会存在创建字符串的开销，会比返回单一值要慢

   - (NSUInteger)hash {
       return [self.firstName hash] ^ [self.lastNmae hash];
   }
   //这样子可以保存较高的效率，又不会过于频繁的重复
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;特定类所具有的等同性判定方法&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;isEqualToString、isEqualToArray、isEqualToDictionary&lt;/li&gt;
&lt;li&gt;如果需要经常判断等同性，可以自己创建等同性判断方法，这样子可以避免检测参数的类型，提升检测效率。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;  - (BOOL)isEqualToPerson:(EOCPerson *)otherPerson {
    if (self == object) return YES;

    if (![_firstName isEqualToString:otherPerson.face]) return NO;
    if (![_lastName isEqualToString:otherPerson.head]) return NO;
    return YES;
  }

  -(BOOL)isEqual:(id)object {
    if ([self class] == [object class]){
        return [self isEqualToPerson:(EOCPerson *)object];
    }else{
        return [super isEqual:object];
    }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;等同性判定的执行深度&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在我们只需要通过判断一个标识符就可以判断对象相等的时候，我们重写方法可以很方便的达到目的，比如判断一个idectifier 就能确定这两个对象相等，就不用判断那么多属性了。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;容器中可变类的等同性 &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;把某个对象放入colloection 之后，不应该再去改变其哈希码了，不然会出现问题，在set 集合会导致改变之后对象存在在一个在原则上 “错误” 的位置。&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;若想检测对象的等同性，请提供 “isEqual：” 与 hash 方法。&lt;/li&gt;
&lt;li&gt;相同的对象必须具有相同的哈希码，但是两个哈希码相同的对象却未必相同。&lt;/li&gt;
&lt;li&gt;不要盲目地逐个检测每条属性，而是应该依照具体需求来指定检测方案。&lt;/li&gt;
&lt;li&gt;编写hash 方法时，应该使用计算速度快而且哈希码碰撞几率低的算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 9 条：以 ”类族模式“ 隐藏实现细节&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;“类族” 是一种很有用的模式，可以隐藏 “抽象基类” （abstract base class）背后的实现细节。&lt;/li&gt;
&lt;li&gt;用户无须自己创建子类实例，只需要调用基类方法来创建即可。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;创建类族&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;每个 “实体子类” 都从基类继承而来，“工厂模式” 是创建类族的办法之一，调用基类方法返回子类实例。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果对象所属的类位于某个类族中，那么查询其类型信息要注意，你可能觉得自己创建了某个类的实例，然后实际上创建的却是其子类的实例。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   -(BOOL) isKindOfClass: classObj; 判断是否是这个类或者这个类的子类的实例
   -(BOOL) isMemberOfClass: classObj; 判断是否是这个类的实例
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Cocoa 里的类族&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;系统框架中有许多类族，大部分collection 类都是类族。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;在使用NSArray 的alloc 方法来获取实例时，该方法首先会分配一个属于某类的实例，此实例充当 “占位数组”（placeholder array）。该数组稍后会转换另一个类的实例，而那个类是NSArray 的实体子类。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;对于Cocoa 中NSArray 这样子的类族，新增子类需要遵循几条规则：&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;子类应该继承自类族中的抽象基类。&lt;/p&gt;

&lt;p&gt;若要编写NSArray 类族的子类，则需要其继承自不可变数组的基类或可变数组的基类。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;子类应该定义自己的数据存储方式。&lt;/p&gt;

&lt;p&gt;编写NSArray 子类时，必须用一个实例变量来存放数组中的对象；NSArray 本身只是包在其他隐藏对象外面的壳，它仅仅定义了所有数组都需要的一些接口。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;子类应当覆写超类文档中指明需要覆写的方法&lt;/p&gt;

&lt;p&gt;在每个抽象基类中，都有一些子类必须覆写的方法，编码前需要看下文档。&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;类族模式可以把实现细节隐藏在一套简单的公共接口后面。&lt;/li&gt;
&lt;li&gt;系统框架经常使用类族。&lt;/li&gt;
&lt;li&gt;从类族的公共抽象基类中继承子类时要当心，若有开发文档，则应首先阅读。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 10 条：在既有类中使用关联对象存放自定义数据&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;可以给类关联许多其他的对象，这些对象通过 “键” 来区分。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;储存对象值的时候，可以指明 ”存储策略“（storage policy），用以维护相应的 ”内存管理语义“，&lt;code&gt;objc_AssociationPolicy&lt;/code&gt;  的枚举定义存储策略。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;| 关联类型                              | 等效的@property 属性  |
   | :-------------------------------- | :--------------- |
   | OBJC_ASSOCIATION_ASSIGN           | assign           |
   | OBJC_ASSOCIATION_RETAIN_NONATOMIC | nonatomic，retain |
   | OBJC_ASSOCIATION_COPY_NONATOMIC   | nonatomic，copy   |
   | OBJC_ASSOCIATION_RETAIN           | retain           |
   | OBJC_ASSOCIATION_COPY             | copy             |&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;下列方法可以管理关联对象：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)
   此方法以给定的键和策略为某对象关联对象值

   id objc_getAssociatedObject(id object, const void *key)
   此方法根据给定的键从某对象中获取相应的对象值

   void objc_removeAssociatedObjects(id object)
   此方法移除指定对象的全部关联对象

   设置关联对象用的键是不透明指针（opaque pointer），其指向的数据结构不局限于某种特定类型的指针。
   设置关联对象值时，若想令两个键匹配到同一个值，则两者必须是完全相同的指针，所以在设置关联对象值时，通常使用静态全局变量做键。
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;可以通过 “关联对象” 机制来把两个对象连起来。&lt;/li&gt;
&lt;li&gt;定义关联对象时可指定内存管理语义，用以模仿定义属性时所采用的 “拥有关系” 与 “非拥有关系”。&lt;/li&gt;
&lt;li&gt;只有在其他做法不可行时才应选用关联对象，因为这种做法通常会引入难于查找的bug。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 11 条：理解 objc_msgSend 的作用&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;调用对象方法，在Objective-C 中叫做 “传递消息”（pass a message），消息有 “名称”（name）或“选择子”（selector），可以接受参数，而且可能还有返回值。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;objc_megSend 的原型： &lt;code&gt;void objc_msgSend(id self,SEL cmd,...)&lt;/code&gt;  ，是一个 “参数个数可变的函数”，能够接受两个或两个以上的参数，第一个参数代表接收者，第二个参数代表选择子，后续参数就是参数。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;objc_megSend 函数会依据接收者和选择子来调用适当的方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在接收者所属的类搜寻其 “方法列表”&lt;/li&gt;
&lt;li&gt;找不到的话，就沿着继承体系继续向上查找&lt;/li&gt;
&lt;li&gt;最终还是找不到相符的方法就执行 “消息转发”&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;objc_msgSend 会将匹配结果缓存在 “快速映射表”（fast map）里面，每个类都有这样子的一块缓存，接下来还向该类发送一样的消息，那么执行起来就很快了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这里有些特殊情况，需要由Objective-C 运行环境的另外一些函数来处理：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;objc_msgSend_stret ：如果待发送的消息要返回结构体，那么可以交由此函数处理。只有当CPU 寄存器能够容纳得下消息返回类型时，这个函数才能处理此消息。若是返回值无法容纳于CPU 寄存器（比如说返回的结构体太大了），那么就由另外一个函数执行派发。此时，那个函数会通过分配在栈上的某个变量来处理消息所返回的结构体。&lt;/li&gt;
&lt;li&gt;objc_msgSend_fpret：如果消息返回的是浮点数，可以交由此函数处理。这个函数是为了处理x86 等架构CPU 中某些令人惊讶的奇怪状况。&lt;/li&gt;
&lt;li&gt;objc_msgSendSuper：如果要给超类发消息，那么就交由此函数处理。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每个类里都有一张函数表，选择子的名称则是表的 “键”，对应的值都是指向函数的指针。objc_msgSend 等函数就是通过这个函数表来寻找应该执行的方法并执行跳转的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果某函数的最后一项操作是调用另外一个函数，那么就可以运用 “尾调用优化” 技术。编译器会生成跳转至另外一个函数所需的指令码，而且不会向调用栈推入新的 “栈帧”。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;消息由接收者、选择子及参数构成。给某对象 “发送消息” 也就是相当于在该对象上 “调用方法”。&lt;/li&gt;
&lt;li&gt;发给某对象的全部消息要由 “动态消息派发系统” 来处理，该系统会查出对应的方法，并执行其代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 12 条：理解消息转发机制&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;当对象接收到无法解读的消息后，就会启动 “消息转发”（message forwarding）机制，程序员可经由此过程告诉对象应该如何处理未知消息。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消息转发分为两大阶段：&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一阶段选征询接收者，所属的类，看其是否能动态添加方法，以处理当前这个 “未知的选择子“（unknown seletor），这叫做 ”动态方法解析“（dynamic method resolution）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二阶段涉及 ”完整的消息转发机制“（full forwarding mechanism）。如果运行期系统已经把第一阶段执行完了，那么接收者自己就无法再以动态新增方法的手段来响应包含该选择子的消息了。这里的第二阶段又分为下面两小步：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先，请接收者看看有没其他对象能处理这条消息；若有，则运行期系统会把消息转给那个对象，于是消息转发过程结束，一切正常。&lt;/li&gt;
&lt;li&gt;若没有 ”备援的接收者“（replacement receiver），则启动完整的消息转发机制，运行期系统会把与消息有关的全部细节都封装到NSInvocation 对象中，再给接受者最后一次机会，令其设法解决当前还未处理的这条消息。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;动态方法解析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对象在收到无法解读的消息后，首先将调用其所属类的下列类方法：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;+ (BOOL)resolveClassMethod:(SEL)sel
+ (BOOL)resolveInstanceMethod:(SEL)sel

//表示这个类是否能新增一个方法来处理此选择子
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;备援接收者&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当前接收者还有第二次机会处理未知的选择子，运行期系统会它：能不能把这条消息转发给其他接收者来处理：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;- (id)forwardingTargetForSelector:(SEL)aSelector
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;我们无法操作经由这一步所转发的消息，若是想在发送给备援接收者之前先修改消息内容，那就得通过完整的消息转发机制。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;完整的消息转发&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;将消息有关的信息全部丢到NSInvacation 对象中，把消息指派给目标对象&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;- (void)forwardInvocation:(NSInvocation *)anInvocation
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;若对象无法响应某个选择子，则进入消息转发流程。&lt;/li&gt;
&lt;li&gt;通过运行期的动态方法解析功能，我们可以在需要用到的某个方法时再将其加入类中。&lt;/li&gt;
&lt;li&gt;对象可以把其无法解读的某些选择子转交给其他对象来处理。&lt;/li&gt;
&lt;li&gt;经过上述两步之后，如果还是没办法处理选择子，那就启动完整的消息转发机制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 13 条：用 “方法调配技术” 调试 “黑盒方法”&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;不需要源代码，也不需要通过继承子类来覆写方法就能改变这个类本身的功能，新功能在本类的所有实例都生效，此方案称为 “方法调配”（method swizzling）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每个类有个方法列表（函数指针 IMP），各自映射到自己的方法实现，只要我们能操作这个函数指针的指向，我们就可以动态的增加替换原有的方法。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;互换两个已经写好的方法实现：&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   void method_exchangeImplementations(Method m1, Method m2) 

   方法实现获取：
   Method class_getInstanceMethod(Class cls, SEL name)  
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;为已有方法增加新功能：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   Method originalMethod = class_getInstanceMethod(class, originalSelector);
       Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);
       BOOL didAddMethod =
       class_addMethod(class,
                       originalSelector,
                       method_getImplementation(swizzledMethod),
                       method_getTypeEncoding(swizzledMethod));

       if (didAddMethod) {
           class_replaceMethod(class,
                               swizzledSelector,                                                method_getImplementation(originalMethod),
                   method_getTypeEncoding(originalMethod));
       } else {
          method_exchangeImplementations(originalMethod, swizzledMethod);
       }
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在运行期，可以向类中新增或替换选择子所对应的方法实现。&lt;/li&gt;
&lt;li&gt;使用另一份实现来替换原有的方法实现，这道工序叫做 “方法调配”，开发者常用此技术向原有实现中添加新功能。&lt;/li&gt;
&lt;li&gt;一般来说，只有调试程序的时候才需要在运行期修改方法实现，这种做法不宜滥用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 14 条：理解 “类对象” 的用意&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;每个Objective-C 对象实例都是指向某块内存数据的指针。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Objective-C 对象所用的数据结构&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   struct objc_object {
       Class isa;
   };

   /// A pointer to an instance of a class.
   typedef struct objc_object *id;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;每个对象结构体首个成员是Class 类的变量，定义了对象所属的类，通常称为 “is a” 指针。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Class 对象的数据结构定义：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   struct objc_class {
       Class isa  OBJC_ISA_AVAILABILITY;

   #if !__OBJC2__
       Class super_class                                        OBJC2_UNAVAILABLE;
       const char *name                                         OBJC2_UNAVAILABLE;
       long version                                             OBJC2_UNAVAILABLE;
       long info                                                OBJC2_UNAVAILABLE;
       long instance_size                                       OBJC2_UNAVAILABLE;
       struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;
       struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;
       struct objc_cache *cache                                 OBJC2_UNAVAILABLE;
       struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;
   #endif

   } OBJC2_UNAVAILABLE;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;Class 首个变量也是isa 指针，说明Class 本身也是Objective-C 对象，指向 “元类”（meta class）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在类继承体系中查询类型信息&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;“isMemberOfClass” 判断对象是否为某个特定类的实例&lt;/li&gt;
&lt;li&gt;“isKindOfClass” 判断出对象是否为某类或其派生类的实例&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;每个实例都有一个指向Class 对象的指针，用以表明其类型，而这些Class 对象则构成了类的继承体系。&lt;/li&gt;
&lt;li&gt;如果对象类型无法在编译器确定，那么就应该使用类型信息查询方法来探知。&lt;/li&gt;
&lt;li&gt;尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 08 May 2017 00:00:00 +0800</pubDate>
        <link>http://pengxuyuan.github.io/2017/05/Effective-Objective-C-2.0-two/</link>
        <guid isPermaLink="true">http://pengxuyuan.github.io/2017/05/Effective-Objective-C-2.0-two/</guid>
        
        
      </item>
    
      <item>
        <title>Effective Objective-C 2.0 总结（一）</title>
        <description>&lt;h2&gt;熟悉Objective-C&lt;/h2&gt;

&lt;h3&gt;前言&lt;/h3&gt;

&lt;p&gt;最经买了本&lt;a href=&quot;http://item.jd.com/11779514.html&quot;&gt;编写高质量代码 改善Objective-C程序的61个建议&lt;/a&gt;，拿到手看了下目录感觉内容比这本52个有效方法更深点，之前的这本也是浅浅的看过，具体讲什么也不是很记得了，所以打算先重新看下这本52个有效方法，然后再来拜读新入手的这本。&lt;/p&gt;

&lt;p&gt;这里准备记录下&lt;a href=&quot;http://item.jd.com/11402853.html&quot;&gt;Effective Objective-C 2.0 编写高质量iOS与OS X 代码的52个有效方法&lt;/a&gt;这本提到的知识点。&lt;/p&gt;

&lt;h3&gt;第 1 条：了解Objective-C 语言的起源&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Objective-C 在C 语言基础上添加了面向对象特性。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;关于面向过程、面向对象的区别大概是：面向对象是将事物高度抽象化， 面向过程是一种自顶向下的编程。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。 &lt;/p&gt;

&lt;p&gt;面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。 &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个问题没有固定的答案，每个人回答的思路都是不一样的，这里可以看下逼乎上面的回答。（PS：是在下经验尚浅，不知如何回答）&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/27468564?sort=created&quot;&gt;“面向对象&amp;quot;和&amp;quot;面向过程&amp;quot;到底有什么区别？&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用消息结构的语言，其运行时所应执行的代码由运行环境来决定；而使用函数调用的语言，则由编译器决定。（Objective-C 利用运行时系统（Runtime ）来做到消息传递，也叫做动态绑定 ）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Objective-C 的重要工作都由 “运行期组件”（runtime component）而非编译器来完成，运行期组件本质上就是一种与开发者所编代码相链接的 “动态库”（dynamic libary），其代码能把开发者编写的所有程序粘合起来。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;关于静态库跟动态库的区别在于：静态库在编译的时候直接拷贝一份到应用程序的，会使得程序变大；动态库是在运行的时候加载到内存，程序会链接到动态库，不会使得程序变大，动态库相当于共享库，多个应用程序之间可以共享。&lt;/p&gt;

&lt;p&gt;关于静态库、动态库的知识点以及制作：&lt;a href=&quot;http://blog.csdn.net/liangliang2727/article/details/52941394&quot;&gt;iOS 静态库和动态库的基本介绍和使用&lt;/a&gt;、&lt;a href=&quot;http://www.cnblogs.com/Jenaral/p/5530383.html&quot;&gt;iOS 静态库，动态库与 Framework 浅析&lt;/a&gt;、&lt;a href=&quot;https://www.valiantcat.cn/index.php/2017/04/24/45.html&quot;&gt;组件化-动态库实战&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Objective-C 是C 的 “超集”，所以C 语言中的所有功能在编写Objective-C 代码时依然适用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;超集的意思大概就像爸爸跟儿子的区别：S1 就是 S2 的超集，S2 有的 S1 都有。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xnp79.com1.z0.glb.clouddn.com/64380cd7912397dd663433635f82b2b7d0a2870c.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;C 语言的内存模型（memory medel ），对象所占的内存总是分配在 “堆空间”（heap space）中，而绝不会分配在 “栈”（stack）上，不能在栈上面分配Objective-C 对象。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;分配在堆中的内存必须直接管理，而分配在栈上用于保存变量的内存则会在其栈帧弹出时自动清理，Objective-C 将堆内存管理抽象出来了，不需要用malloc 及free 来分配或释放对象所占内存，Objective-C 运行期环境把这部分工作抽象成一套内存管理架构，叫 ”引用计数“ 。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/anyaas/article/details/17099377&quot;&gt;C语言内存模型及运行时内存布局&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对于创建结构体相比，创建对象需要额外的开销，例如分配及释放堆内存等操作，所以Objective-C 对于 ”非对象类型“ 通常都是适用结构体来存储，储存在栈空间。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Objective-C 为C 语言添加了面向对象特性，是其超集。Objective-C 使用动态绑定的消息结构，也就是说，在运行时才会检查对象类型。接收一条消息之后，究竟应执行何种代码，由运行期环境而非编译器来决定。&lt;/li&gt;
&lt;li&gt;理解C 语言的核心概念有助于写好Objective-C 程序。尤其要掌握内存模型与指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 2 条：在类的头文件中尽量少引用其他头文件&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Objective-C  标准编写类方式也是头文件、实现文件组成&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;场景：A 类的头文件中有一个B 类型的属性&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   @property (nonatomic,strong) B *b;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;要通过编译，处理方式有3种：使用#import  #incudule  @class关键字&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用#import #include 这个时候可以解决问题，但不够优雅，这里就要知道B 类的具体细节，这里会引用到B 类的具体实现，会增加编译时间&lt;/li&gt;
&lt;li&gt;使用@class关键字，@class关键字 “向前声明” 告诉你有这个类，具体定义不清楚，这里就不依赖B 类的信息，这里从另外一个角度来看，可以减少A、B 之间的耦合&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;两个类互相引用的问题： A 类中有B 类的属性，B 类中也有A 类的属性&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;首先说明 #import 是由gcc 编译器支持的，其实就是 #incudule 改良版本；#import 确保了引用的这个文件只被引进一次，而#incudule 就会出现死循环引用，导致程序报错；&lt;/li&gt;
&lt;li&gt;这里使用 #import、#incudule 都不能解决这个循环问题，这里只能使用@class 来破解&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;所以应该将引入头文件的时机尽量延后，只有确有需要的时候才引用，这样子可以减少类的使用者所需引用的头文件数量。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用@class 可以减少.h中对其他类的依赖、减少链接到其他类所需要的时间，从而降低编译时间。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一般来说在.h中，首选@class 然后在迫不得已的时候才用#import (继承，实现协议)，对于协议来说 可以使用类扩展，在.m中声明一个匿名类别来声明，只有在子类需要统一实现这个协议的时候才会放在.h中，暂时没有了解到其他情况得非在.h中#import协议。&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;除非确有必要，否则不要引入头文件。一般来说，应在某个类的头文件中使用向前声明来提及别的类，并在实现文件中引入那些类的头文件。这样子可以尽量降低类之间的耦合（coupling）。&lt;/li&gt;
&lt;li&gt;有时无法使用向前声明，比如要声明某个类遵循一项协议。这种情况下，尽量把 “该类遵循某协议” 的这样声明移至 “class-continuation 分类中” 中。如果不行的话，就把协议单独放在一个头文件，然后将其引入。&lt;/li&gt;
&lt;li&gt;“class-continuation 分类”，其实就是一个特殊的分类，写在实现文件中的分类，只能被该实现文件所引用&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 3 条：多用字面量语法，少用与之等价的方法&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用字面量语法可以缩减源代码长度，使其更加易读，减少代码出错机率。字面量语法实际是一种 “语法糖”，也称 “糖衣语法”，是指计算机语言中与另外一套语法等效但是开发者用起来却更加方便的语法。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;字面数值&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   NSNumber *someNumner = @1;
   NSNumber *intNumner = @1;
   NSNumber *floatNumner = @2.5f;
   NSNumber *doubleNumner = @3.14159;
   NSNumber *charNumner = @&amp;#39;s&amp;#39;;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;字面量数组&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   NSArray *array = @[@&amp;quot;a&amp;quot;,@&amp;quot;b&amp;quot;@&amp;quot;c&amp;quot;];
   NSString *string = array[0];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;字面量字典&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   NSDictionary *dict = @{@&amp;quot;key&amp;quot;:@&amp;quot;value&amp;quot;};
   NSString *string = dict[@&amp;quot;key&amp;quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;可变数组与字典&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   NSMutableArray *mutable = [@[@&amp;quot;a&amp;quot;,@&amp;quot;b&amp;quot;] mutableCopt];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;局限性&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;字面量所创建的对象必须属于Foundation 框架，如果自定义这些类的子类，则无法用字面量语法创建其对象。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;字符串字面量创建的是常量，对象不在持有了也不会立马被释放&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   例子：

   __strong NSObject *yourObject= [NSObject new];
   __weak NSObject *myObject = yourObject;
   yourObject = nil;
   __unsafe_unretained NSObject *theirObject = myObject;
   NSLog(@&amp;quot;%p %@&amp;quot;, yourObject, yourObject);
   NSLog(@&amp;quot;%p %@&amp;quot;, myObject, myObject);
   NSLog(@&amp;quot;%p %@&amp;quot;, theirObject, theirObject);

   2017-02-16 11:02:37.702543 TKApp[1767:599122] 0x0 (null)
   2017-02-16 11:02:38.612380 TKApp[1767:599122] 0x0 (null)
   2017-02-16 11:02:40.985613 TKApp[1767:599122] 0x0 (null)


   __strong NSString *yourString = @&amp;quot;Your String&amp;quot;; 
   __weak NSString *myString = yourString;
   yourString = nil;
   __unsafe_unretained NSString *theirString = myString;
   NSLog(@&amp;quot;%p %@&amp;quot;, yourString, yourString);
   NSLog(@&amp;quot;%p %@&amp;quot;, myString, myString);
   NSLog(@&amp;quot;%p %@&amp;quot;, theirString, theirString);

   2017-02-16 11:00:42.407410 TKApp[1757:597837] 0x0 (null)
   2017-02-16 11:00:44.340836 TKApp[1757:597837] 0x1013b9480 Your String
   2017-02-16 11:00:45.392346 TKApp[1757:597837] 0x1013b9480 Your String

   这里主要有2个知识点：
   1.关于ARC中的引用计数问题
   2.字符串常量和字符串字面量的区别是什么？

   Line By Line
   第一种情况：
   __strong NSObject *yourObject = [NSObject new];
   yourObject New了一个NSObject对象 并且持有 对象引用计数＋1

   __weak NSObject *myObject = yourObject;
   myObject 指向 yourObject指向的的对象地址 没有持有 对象引用计数 不变

   yourObject = nil;
   yourObject 指向nil 不持有NSObject对象 对象不被持用 引用计数－1 这个时候这个对象自动释放

   __unsafe_unretained NSObject *theirObject = myObject;
   这个时候myObject已经被置为nil了 所以theirObject也为nil

   第二种情况：
   本来第二种情况也应该类似像第一种，这里就是关于字符串常量和字符串字面量的区别了。

   What&amp;#39;s the difference between a string constant and a string literal?

   在这里为什么没有释放的情况跟字符串常量没什么联系，主要是这里是一个字符串字面量，字符串字面值创建了不会再修改了，一个对象持有这个字符串，当它不指向它了，也不会立马释放。
   这里还有个点，Objective-C 会做字符串的编译单元，而且会合并相同字符串的编译单元，来减少额外的消耗去链接这些编译单元。

   NSString *string1 = @“pengxuyuan”;
   NSString *string2 = @“pengxuyuan”;

   string1跟string2内存地址是一样的。
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;参考资料：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/25746/whats-the-difference-between-a-string-constant-and-a-string-literal&quot;&gt;What&amp;#39;s the difference between a string constant and a string literal?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/10922888/weak-nsstring-variable-is-not-nil-after-setting-the-only-strong-reference-to-nil&quot;&gt;Weak NSString variable is not nil after setting the only strong reference to nil&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;应该使用字面量语法来创建字符串、数值、数组、字典。与创建此类对象的常规方法相比，这么做更加简明扼要。&lt;/li&gt;
&lt;li&gt;应该通过取下标操作来访问数组下标或字典中的健所对应的元素。&lt;/li&gt;
&lt;li&gt;用字面量语法创建数组或字典时，若值中有nil，则会抛出异常。因此，务必确保值里不含nil。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 4 条：多用类型常量，少用#define 预处理指令&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;在编码时候多次用到一个变量（数值，字符串等），我们会进行抽取以便修改一处所有用到的地方都会生效。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们可能会使用#define 预处理指令&lt;code&gt;#define ANIMATION_DURATION 0.3&lt;/code&gt; 编译的时候会将遇到的ANIMATION_DURATION 替换成0.3，这样子可以解决问题，但是会存在一些问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;预处理指令是没有包含类型的，有可能会将一些不需替换的也替换掉，导致异常&lt;/li&gt;
&lt;li&gt;还有如果这个预处理被定义在头文件的话，引入了这个头文件的ANIMATION_DURATION 都会被替换，这是我们不希望看到的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个时候我们定义一个常量的话，就可以包含类型信息&lt;code&gt;static const NSTimerInterval kAnimationDuration = 0.3;&lt;/code&gt;  这样子在编译的过程中就可以清楚的知道要替换的类型，如果不一致会报警告，这样子也方便排查问题；常用的命名法是：若常量局限于 “编译单元”（translation-unit，也就是 “实现文件” 中），则在前面加字母k；若常量在类之外可见，则通常已类名作为前缀。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;定义常量的位置很重要。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果将&lt;code&gt;#define ANIMATION_DURATION 0.3&lt;/code&gt;  &lt;code&gt;static const NSTimerInterval kAnimationDuration = 0.3;&lt;/code&gt;  定义在头文件，引入了这个头文件都会有这个名字，而且  &lt;code&gt;static const NSTimerInterval kAnimationDuration = 0.3;&lt;/code&gt;  定义在头文件的话，等于会声明一个全局变量，这样子所有类都可以使用了，这样子我们应该用类型作为前缀。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;static 修饰符则意味该变量仅在此变量的编译单元可见。编译器每收到一个编译单元，就会输出一份 “目标文件”（object file）。在Objective-C 的语境下，”编译单元“ 通常指每个类的实现文件（.m 文件），如果声明此变量不加static，则编译器会为它创建一个 “外部符号”（external symbol），如果其他编译单元也声明同样的变量就会报错了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果用static 和 const 声明一个变量，不会创建符号，而是会像#define 预处理指令一样，将遇到的变量全部替换，但是区别在这样子有变量类型。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果要定义一个外界可见的常量变量（constant variable），可以放在 “全局符号表”（global symbol table）中，来全局使用。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   //In the header file
   extern NSString *const EOCStringConstant;

   //In the implementtation file
   NSString *const EOCStringConstant = @&amp;quot;VALUE&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;编译器会在 “数据段”（data section）为字符串分配存储空间，这里在上面C 语言的内存模型有讲，数据段通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。 &lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;不要用预处理指令定义常量。这样定义出来的常量不含类型信息，编译器只是会在编译前据此执行查找与替换操作。即使有人重新定义了常量值，编译器也不会产生警告信息，这将导致应用程序中的常量值不一致。&lt;/li&gt;
&lt;li&gt;在实现文件中使用static const 来定义 “只在编译单元内可见的常量“（translation-unitspecific constant）。由于此类常量不在全局符号表中，所以无须为其名称加前缀。&lt;/li&gt;
&lt;li&gt;在头文件中使用extern 来声明全局变量，并在相关实现文件中定义其值。这种常量要出现在全局符号表中，所以其名称应加以区隔，通常用与之相关的类型做前缀&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;第 5 条：用枚举表示状态、选项、状态码&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;C++ 11 标准扩充了枚举的特性，最新系统框架使用了 “强类型”（strong type）的枚举。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实现枚举所用的数据类型取决于编译器，不过其二进制位（bit）的个数必须能完全表示下枚举编号才行，一个字节含8个二进制位，所以至多能表示256中（2&lt;sup&gt;8&lt;sup&gt;个）枚举（编号为0～255）的枚举变量。&lt;/sup&gt;&lt;/sup&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;只要枚举定义得对，各选项之间就可通过 “按位或操作符”（bitwise OR operator）来组合。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用宏来定义枚举类型，这些宏具备向后兼容（backward compatibility）能力，如果目标平台编译器支持新标准，那就使用新式语法，否则改用旧式语法。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;   typedef NS_ENUM(NSUInterger,EOCConnectionState) {
    EOCConnectionStateDisconnected,
    EOCConnectionStateConnecting,
    EOCConnectionStateConnected,
   };

   typedef NS_OPTINS (NSUInterger,EOCPermittedDirection) {
        EOCPermittedDirectionUp     = 1 &amp;lt;&amp;lt; 0,
       EOCPermittedDirectionDown    = 1 &amp;lt;&amp;lt; 1,
       EOCPermittedDirectionLeft    = 1 &amp;lt;&amp;lt; 2,
       EOCPermittedDirectionRight   = 1 &amp;lt;&amp;lt; 3,
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;在switch 语句中，最好不要有default 分支，这样子要做到处理所有样式，这样子在新家类型的时候，没有default 编译器会发出警告，让我们注意到。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这些值起个易懂的名字。&lt;/li&gt;
&lt;li&gt;如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，那么就将各选项值定义为2的幂，以便通过按位或操作将其组合起来。&lt;/li&gt;
&lt;li&gt;用NS_ENUM 与 NS_OPTIONS 宏来定义枚举类型，并指明其底层数据类型。这样做可以确保枚举是用开发者所选的底层数据类型实现的，而不会才用编译器所选的类型。&lt;/li&gt;
&lt;li&gt;在处理枚举类型的switch 语句中不要实现defauly 分支。这样的话，加入新枚举之后，编译器就会提示开发者：switch 语句并未处理所有枚举。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 24 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://pengxuyuan.github.io/2017/04/Effective-Objective-C-2.0-one/</link>
        <guid isPermaLink="true">http://pengxuyuan.github.io/2017/04/Effective-Objective-C-2.0-one/</guid>
        
        
      </item>
    
      <item>
        <title>iOS Security 安全白皮书（一）</title>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/pengxuyuan/quzhibo/master/iOS%20Security%20/4DACC0BE-094F-44BE-AE94-6923AACDFC39.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;iOS 安全白皮书是苹果官方提供的，里面有苹果对于安全设计的一些细节介绍，阅读可以更佳理解苹果系统的构造，虽然不能说是看了能很深的明白其设计思路，但是可以增加知识，为以后做安全方面打下基础&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;%5B**https://www.apple.com/business/docs/iOS_Security_Guide.pdf****?****from=timeline&amp;amp;isappinstalled=0**%5D(https://www.apple.com/business/docs/iOS_Security_Guide.pdf?from=timeline&amp;amp;isappinstalled=0)&quot;&gt;官方原文地址&lt;/a&gt;  这个是官方的文档，英文好的同学强烈建议看原文档，个人经验来说，看英文跟看中文完全是两种不同的体验，但是看英文会更加有趣更加深刻&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;%5B**http://www.jianshu.com/p/3a151735fa89#**%5D(http://www.jianshu.com/p/3a151735fa89#)&quot;&gt;17年白皮书翻译&lt;/a&gt;，我是看到巧神推荐才知道有iOS 安全白皮书的，以前对于白皮书的概念还是高中的练习辅导呢，那时候上网找了下有没中文文档，很遗憾没有找到，然后过了半个月这篇翻译就出来了，很快，很强，但是原文都是机翻，然后没有润色，有点难读懂，理解能力强的同学可以直接看，全文都已经翻译好了&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://pan.baidu.com/share/link?shareid=3622394083&amp;amp;uk=809426888&quot;&gt;16年白皮书&lt;/a&gt; 这个无敌，强烈建议大家去看，翻译的堪称完美，至今不知道作者是如何做到的，一句话：无敌，是真的无敌&lt;/p&gt;

&lt;p&gt;在我翻译第一章的时候找到这些优秀的资料，一开始是放弃翻译的了。后来自我反思，以前Blog 我也看了很多，但是印象一直不深，但是这次翻译完第一章給我自己的感觉挺好的，认识了很多新知识点，感觉印象很深刻，所以还是想自己慢慢的翻译下，可以慢慢成长。这次打算自己翻译17年的白皮书和阅读&lt;a href=&quot;https://pan.baidu.com/share/link?shareid=3622394083&amp;amp;uk=809426888&quot;&gt;16年白皮书&lt;/a&gt;，一起讲iOS 安全这方面的知识学习下&lt;/p&gt;

&lt;p&gt;以下是翻译&lt;/p&gt;

&lt;hr&gt;

&lt;h3&gt;Introduction&lt;/h3&gt;

&lt;h3&gt;System Security&lt;/h3&gt;

&lt;h4&gt;Secure boot chain&lt;/h4&gt;

&lt;h4&gt;System Software Authorization&lt;/h4&gt;

&lt;h4&gt;Secure Enclave&lt;/h4&gt;

&lt;h4&gt;Touch ID&lt;/h4&gt;

&lt;h3&gt;Encryption and Data Protection&lt;/h3&gt;

&lt;h4&gt;Hardware security features&lt;/h4&gt;

&lt;h4&gt;File Data Protection  Passcodes&lt;/h4&gt;

&lt;h4&gt;Data Protection classes&lt;/h4&gt;

&lt;h4&gt;Keychain Data Protection&lt;/h4&gt;

&lt;h4&gt;Access to Safari saved passwords&lt;/h4&gt;

&lt;h4&gt;Keybags&lt;/h4&gt;

&lt;h4&gt;Security certifications and programs&lt;/h4&gt;

&lt;h3&gt;App Security&lt;/h3&gt;

&lt;h4&gt;App code signing&lt;/h4&gt;

&lt;h4&gt;Runtime process security&lt;/h4&gt;

&lt;h4&gt;Extensions&lt;/h4&gt;

&lt;h4&gt;App Groups&lt;/h4&gt;

&lt;h4&gt;Data Protection in apps&lt;/h4&gt;

&lt;h4&gt;Accessories&lt;/h4&gt;

&lt;h4&gt;HomeKit&lt;/h4&gt;

&lt;h4&gt;SiriKit&lt;/h4&gt;

&lt;h4&gt;HealthKit&lt;/h4&gt;

&lt;h4&gt;ReplayKit&lt;/h4&gt;

&lt;h4&gt;Secure Notes&lt;/h4&gt;

&lt;h4&gt;Apple Watch&lt;/h4&gt;

&lt;h3&gt;Network Security&lt;/h3&gt;

&lt;h4&gt;TLS&lt;/h4&gt;

&lt;h4&gt;VPN&lt;/h4&gt;

&lt;h4&gt;Wi-Fi&lt;/h4&gt;

&lt;h4&gt;Bluetooth&lt;/h4&gt;

&lt;h4&gt;Single Sign-on&lt;/h4&gt;

&lt;h4&gt;AirDrop security&lt;/h4&gt;

&lt;h3&gt;Apple Pay&lt;/h3&gt;

&lt;h4&gt;Apple Pay components&lt;/h4&gt;

&lt;h4&gt;How Apple Pay uses the Secure Element&lt;/h4&gt;

&lt;h4&gt;How Apple Pay uses the NFC controller&lt;/h4&gt;

&lt;h4&gt;Credit, debit, and prepaid card provisioning&lt;/h4&gt;

&lt;h4&gt;Payment authorization  Transaction-specific dynamic security code&lt;/h4&gt;

&lt;h4&gt;Contactless payments with Apple Pay&lt;/h4&gt;

&lt;h4&gt;Paying with Apple Pay within apps&lt;/h4&gt;

&lt;h4&gt;Paying with Apple Pay on the web&lt;/h4&gt;

&lt;h4&gt;Rewards cards  Suspending, removing, and erasing cards&lt;/h4&gt;

&lt;h3&gt;Internet Services&lt;/h3&gt;

&lt;h4&gt;Apple ID&lt;/h4&gt;

&lt;h4&gt;iMessage&lt;/h4&gt;

&lt;h4&gt;FaceTime&lt;/h4&gt;

&lt;h4&gt;iCloud&lt;/h4&gt;

&lt;h4&gt;iCloud Keychain&lt;/h4&gt;

&lt;h4&gt;Siri&lt;/h4&gt;

&lt;h4&gt;Continuity  Safari Suggestions, Spotlight Suggestions, Lookup, #images, and News&lt;/h4&gt;

&lt;h4&gt;Widget in Non-News Countries&lt;/h4&gt;

&lt;h3&gt;Device Controls&lt;/h3&gt;

&lt;h4&gt;Passcode protection&lt;/h4&gt;

&lt;h4&gt;iOS pairing model&lt;/h4&gt;

&lt;h4&gt;Configuration enforcement&lt;/h4&gt;

&lt;h4&gt;Mobile device management (MDM)&lt;/h4&gt;

&lt;h4&gt;Shared iPad&lt;/h4&gt;

&lt;h4&gt;Apple School Manager&lt;/h4&gt;

&lt;h4&gt;Device Enrollment&lt;/h4&gt;

&lt;h4&gt;Apple Configurator 2&lt;/h4&gt;

&lt;h4&gt;Supervision&lt;/h4&gt;

&lt;h4&gt;Restrictions&lt;/h4&gt;

&lt;h4&gt;Remote Wipe&lt;/h4&gt;

&lt;h4&gt;Lost Mode&lt;/h4&gt;

&lt;h4&gt;Activation Lock&lt;/h4&gt;

&lt;h3&gt;Privacy Controls&lt;/h3&gt;

&lt;h4&gt;Location Services&lt;/h4&gt;

&lt;h4&gt;Access to personal data&lt;/h4&gt;

&lt;h4&gt;Privacy policy&lt;/h4&gt;

&lt;h3&gt;Apple Security Bounty&lt;/h3&gt;

&lt;h3&gt;Conclusion&lt;/h3&gt;

&lt;h4&gt;A commitment to security&lt;/h4&gt;

&lt;h3&gt;Glossary&lt;/h3&gt;

&lt;h3&gt;Document Revision History&lt;/h3&gt;

&lt;hr&gt;

&lt;h2&gt;Introduction&lt;/h2&gt;

&lt;p&gt;苹果设计的 iOS 平台以安全为核心。当我们着手打造最好的移动平台时，我们借鉴了几十年的经验，打造了全新的架构。我们考虑了桌面环境的安全隐患，并在 iOS 的设计中建立了新的安全方法。我们开发并纳入许多创新功能，来加强手机安全和保护整个系统。因此，iOS 在移动设备安全方面有大的飞跃&lt;/p&gt;

&lt;p&gt;每一个 iOS 设备结合软件、硬件和服务一起工作，为了是提供更加具有安全性和透明性的用户体验。iOS 不仅是保护本地的设备和它的数据，而是扩展到整个生态系统，包括用户在本地做的一切，还有在网络上的各种互联网服务&lt;/p&gt;

&lt;p&gt;iOS 和 iOS 设备提供先进的安全功能，并且它们也很容易使用。许多功能是默认启用的，因此IT 部门不需要去大量的配置。但是关键的安全功能，如设备加密是不可配置的，所以用户不会因为错误的操作而禁止设备加密。其他功能，例如指纹识别，在提高用户体验方面，可以更简单，更直观的保护设备&lt;/p&gt;

&lt;p&gt;本文档提供了如何在 iOS 平台上实现安全技术和功能的详细细节。它也将有助于开发者将 iOS 平台安全技术和功能与自己的政策和程序相结合，以满足其特定的安全需求。&lt;/p&gt;

&lt;p&gt;这个文档主要是讨论以下几个话题:&lt;br&gt;
* 系统安全：为 iPhone、iPad、iPod touch 平台集成安全的软件和硬件&lt;br&gt;
* 加密和数据保护：架构和设计来保护用户数据，在设备丢失或被盗，或未经授权的人试图使用或修改它的情况下&lt;br&gt;
* 应用程序安全：使应用程序安全运行，且不影响平台完整性&lt;br&gt;
* 网络安全：使用行业标准的网络协议，提供安全的认证和加密的数据传输&lt;br&gt;
* 苹果支付：关于安全支付的实现&lt;br&gt;
* 互联网服务：苹果为通讯，同步，和备份做的网络基础设施
* 设备控制：允许管理 iOS 设备，防止未经授权的使用，如果设备丢失或被盗可以远程清除数据。&lt;br&gt;
* 隐私控制：可以控制是否访问位置服务和用户数据。  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/pengxuyuan/quzhibo/master/0B32958D-5334-4746-A1B2-F0D005BE1EE4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h2&gt;System Security&lt;/h2&gt;

&lt;p&gt;系统安全设计，软件和硬件在所有的iOS 设备中的核心组件都是安全的，这包括启动过程、软件更新、安全区域。这种架构在iOS中是安全的核心，不会有另外一种方式让可以运行设备&lt;/p&gt;

&lt;p&gt;在iOS 设备中，硬件和软件紧密的相结合，确保系统的每一个组件都是可信任的，并且系统是作为一个有效的整体。从最初的启动到iOS 软件更新到第三方应用程序,每一个步骤进行了分析和审查,以确保硬件和软件以最佳性能结合,并且正确合理的使用资源&lt;/p&gt;

&lt;p&gt;进入设备固件升级模式 （DFU Device Firmware Upgrade）&lt;/p&gt;

&lt;p&gt;确定只有未修改的Apple 签名代码，才可以恢复设备进入DFU 模式后，将其恢复到已知的良好状态。DFU 模式可以手动的进入：首先用USB 电缆将设备连接到电脑上，然后同时按住Home 键和电源键，然后过了8秒，放开电源键继续按住Home 键 提示：当设备进入DFU 模式屏幕上是不会出现任何东西的，如果苹果Logo 出现了，就是电源键被按住的时间太久了  &lt;/p&gt;

&lt;h3&gt;Secure boot chain 安全启动链&lt;/h3&gt;

&lt;p&gt;启动过程的每一步都包含了苹果密码签名的组件，来确保完整性，并且只有信任链验证后才能进入。这包括引导装载器、内核,内核扩展,基带固件。安全启动链确保这些最底层的软件不会被篡改&lt;/p&gt;

&lt;p&gt;当启动iOS 设备，它的应用处理器会立刻执行只读存储器（ROM）中的代码，这里称之为Boot ROM。这些不可改变的代码，被称之为硬件信任根(hardware root of trust)，在芯片制造的时候就烧进去了，而且是默认信任的&lt;/p&gt;

&lt;p&gt;引导ROM 代码包含了苹果根CA 的公钥，在允许进入加载之前用来验证iBoot 引导装载器是否是苹果签名的，这个是在信任链中的第一步，来确保接下来的每一步都是苹果签名认证的，当iBoot 完成它的任务时，它会验证和运行iOS 内核。对于搭载S1，A9或则A系列处理器的设备，Boot ROM 验证一个额外的低级引导装载器（Low-Level Bootloader  LLB），依次加载和验证iBoot&lt;/p&gt;

&lt;p&gt;如果引导过程这一步无法加载或者无法验证下一步的程序，启动会被停止，这个时候设备屏幕会显示 “Connect to iTunes” ，这个就是恢复模式。如果引导Boot ROM 无法加载或则验证低级引导装载器，这个时候会进入到DFU 模式（设备固件升级模式）。对于这两种情况，必须将设备用USB 线缆连接到电脑的itunes 恢复到工厂默认设置。对于手动进入恢复模式更多信息可以查看链接：&lt;a href=&quot;&quot;&gt;https://support.apple.com/kb/HT1808&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对于蜂窝移动数据接入的设备，基带子系统也在相似的安全启动过程中，利用基带处理器来签名软件和密钥验证&lt;/p&gt;

&lt;p&gt;设备有安全区域（Secure Enclave），这个安全区域处理器也会利用一个安全启动的启动过程来确保它由苹果来独立的软件验证和签名&lt;/p&gt;

&lt;h3&gt;System Software Authorization  系统软件授权&lt;/h3&gt;

&lt;p&gt;苹果公司定期发布软件更新来解决新兴的安全问题，并且提供新功能，同时这些支持更新到所有的iOS 设备，用户在设备上接受到iOS 更新提示，可以通过iTunes 和无线来更新，并且鼓励大家快速采用最新的安全补丁&lt;/p&gt;

&lt;p&gt;上面所述的启动过程有助于确保在设备上只能安装苹果签名的代码。防止设备被降级到旧版本以致缺乏最新的安全保护，iOS 使用这一过程被称之为系统软件授权。如果降级是可能的，攻击者可以在设备安装一个旧版本的iOS 系统来利用漏洞，但是这个漏洞已经在新版本被修复了&lt;/p&gt;

&lt;p&gt;在设备上有安全区域（Secure Enclave），安全区域处理器也会利用系统软件授权来确保软件的完整性，并且防止降级设备。具体可以看接下来的安全区域章节&lt;/p&gt;

&lt;p&gt;iOS 软件更新可以使用iTunes 更新，也可以在设备上使用空中下载技术（over the air OTA）。利用iTunes 更新，会下载一份完整的iOS 系统并安装，用OTA 更新只会下载必要的组件进行更新，提高网络效率，并不会下载整个操作系统。另外，软件更新可以被缓存在macOS 服务器运行在本地网络服务，所以iOS 设备不需要访问苹果服务器获取必要的更新数据&lt;/p&gt;

&lt;p&gt;在iOS 升级过程中，iTunes 更新（或者利用设备的OTA 更新），会连接到苹果安装授权服务器，然后发送一系列的加密测量结果（cryptographic measurements ），里面有每个安装包需要更新的信息（例如：iBoot、内核、OS 映像），还有一个临时随机的不重复的（anti-replay）值，设备的唯一ID（ECID）&lt;/p&gt;

&lt;p&gt;授权服务器会检查这个加密的测量结果，查看是否允许安装，如果匹配成功，会将ECID 加到这个测量结果中并且标记这个结果。在升级过程中，服务器将一组完整的签名数据传递给设备。添加一个处理过的ECID 到请求设备，只对加密的测量结果授权和认证，服务器确保只会由苹果提供更新&lt;/p&gt;

&lt;p&gt;启动时信任链会评估验证这个签名是从苹果来的，和从磁盘中加载这个测量结果，结合设备的ECID，匹配所要更新的签名&lt;/p&gt;

&lt;p&gt;这些步骤确保为特定的设备授权，和一个设备的旧版系统的不能被复制到另外一个设备上面去，可以防止攻击者保存服务器的响应，并且利用它来篡改设备或修改系统软件&lt;/p&gt;

&lt;h3&gt;Secure Enclave 安全区域&lt;/h3&gt;

&lt;p&gt;安全区域是一个协助处理器，是在Apple S2，Apple A7 以及后面的A 系列处理器中出现的。它使用加密内存，包括硬件随机数发生器。安全区域提供了所有的数据保护密钥管理的加密操作，并且维护数据的完整性，即使内核已受到破坏。安全区域跟应用处理器通讯被隔离在一个中断驱动信箱和一个共享内存数据缓冲器中&lt;/p&gt;

&lt;p&gt;安全区域运行一个苹果定制的L4 微核，安全区域利用自己的安全启动去做一个个性化的软件更新，这里也是跟应用处理器分离的。在A9 及以后的A 系列的处理器中，芯片会安全的生成一个UID（唯一的ID）。这个UID 连苹果和系统的其他部分都不知道的&lt;/p&gt;

&lt;p&gt;当设备启动的时候，会创建一个临时密钥，并跟UID 混淆在一起，这个用来对设备内存模块中的安全区域进行加密。除了在苹果A7 处理器上，安全区域的内存也用这个临时密钥做了加密&lt;/p&gt;

&lt;p&gt;另外，数据用一个随机值和UID 混淆后加密存储在安全区域的文件系统中&lt;/p&gt;

&lt;p&gt;安全区域负责处理指纹识别传感器的指纹数据，判断指纹是否有效，然后允许访问设备或者通过用户的购买行为，处理器跟指纹识别传感器是在串行外设接口上通讯的，处理器将数据传输到安全区域但是处理器并不能读取数据内容，这个数据用指纹识别传感器跟安全区域的一个设备共享密钥来进行加密和验证，这个密钥用AES 方法来加密，两边都会提供一个随机密钥，并且用AES-CCM 来传输数据&lt;/p&gt;

&lt;h3&gt;Touch ID 指纹识别传感器&lt;/h3&gt;

&lt;p&gt;Touch ID 是指纹识别传感器系统，可以更快、更简单、更安全的解锁手机。该技术会从任何角度读取指纹数据，并随着时间的推移更多地了解用户的指纹，随着每次使用的其他重叠节点被识别，传感器继续扩展指纹图&lt;/p&gt;

&lt;p&gt;Touch ID 可以让用户使用更长、更复杂、更实用的密码，因为用户现在不用频繁地输入密码。Touch ID 克服了用密码解锁的不便，但不是通过替换它来解决，是在一定的时间和场景内可以使用 Touch ID 来安全的访问设备&lt;/p&gt;

&lt;h3&gt;Touch ID and passcodes 指纹识别传感器和密码&lt;/h3&gt;

&lt;p&gt;要使用Touch ID，用户必须要为手机设置一个解锁密码，当Touch ID 扫描并识别到一个已经注册过的指纹时，设备可以在不需要密码的情况下解锁。Touch ID 通常可以代替密码，但是在以下情况仍然需要使用密码：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;设备刚刚启动或者重启&lt;/li&gt;
&lt;li&gt;设备48小时内没有被解锁&lt;/li&gt;
&lt;li&gt;在过去的156小时（六天半天）中，密码未被用于解锁设备，Touch ID在过去4小时内未解锁设备&lt;/li&gt;
&lt;li&gt;设备已收到远程锁定命令&lt;/li&gt;
&lt;li&gt;指纹识别失败5次&lt;/li&gt;
&lt;li&gt;使用Touch ID设置或注册新手指时&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当启用Touch ID时，按下睡眠/唤醒按钮时，设备立即锁定。很多用户会设置一个解锁的宽限期，以避免每次使用该装置输入密码。使用Touch ID，设备会在每次进入睡眠状态时锁定，并在每次唤醒时都需要指纹或者输入密码&lt;/p&gt;

&lt;p&gt;Touch ID 可以最多设置5根不同的手指，随着一根手指的录入，跟别人误匹配的机率是50万分之一。在Touch ID 指纹识别失败了五次，用户才需要输入密码以获取访问权限&lt;/p&gt;

&lt;h3&gt;Other uses for Touch ID&lt;/h3&gt;

&lt;p&gt;Touch ID 也可以用于Apple Pay（苹果提供的安全支付），有关更多Touch ID 的信息，请参阅本文档的Apple Pay 部分&lt;/p&gt;

&lt;p&gt;另外，第三方应用程序可以使用系统提供的API 来让用户使用Touch ID 或密码进行身份验证。应用程序仅被通知身份验证是否成功; 它无法访问Touch ID 或与注册指纹相关联的数据&lt;/p&gt;

&lt;p&gt;Keychain 也一样可以使用Touch ID 来解锁，只有通过指纹识别或者输入密码才能被访问。应用程序开发人员还有API 来验证用户是否设置了密码，因此可以使用Touch ID对钥匙串项进行身份验证或解锁&lt;/p&gt;

&lt;p&gt;在iOS 9 及以后，开发者可以做以下一些事情：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Require that Touch ID API operations don’t fall back to an application password or the device passcode. Along with the ability to retrieve a representation of the state of enrolled fingers, this allows Touch ID to be used as a second factor in security sensitive apps.&lt;/li&gt;
&lt;li&gt;Generate and use ECC keys inside Secure Enclave. These keys can be protected byTouch ID. Operations with these keys are always done inside Secure Enclave afterSecure Enclave authorizes the use. Apps can access these keys using Keychainthrough SecKey. SecKeys are just references to the Secure Enclave keys and the  keys never leave Secure Enclave.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Touch ID 也可以直接解锁 iTunes Store、App Store、iBooks Store 的购买项目，用户从而不用输入Apple ID 的密码。当用户授权购买的时候，设备和商店之间交换认证令牌。令牌和加密随机数保存在安全区域（Security Enclave）中，这个随机数是被所有设备和iTunes Store 共享的安全区域密钥进行签名的。在iOS 10 中，Touch ID 保护安全区域中的ECC 密钥，这个密钥是用于通过认证购买的请求&lt;/p&gt;

&lt;h3&gt;Touch ID security&lt;/h3&gt;

&lt;p&gt;仅当Home按钮的电容钢环检测到手指的触摸时，指纹传感器才会起作用，这将触发高级成像阵列扫描手指并将扫描发送到安全区域&lt;/p&gt;

&lt;p&gt;光栅扫描临时存储在安全存储器内的加密存储空间中，同时被矢量化分析，然后被丢弃。这个分析是使用subdermal ridge flow angle mapping 技术，这是丢弃重建用户实际指纹所需的细节数据的有损过程。生成的结果是没有任何身份信息相关的数据，并且加密存储在安全区域，只能有安全区域访问，而且永远不会发送給苹果或者备份在iCloud、iTunes 上面&lt;/p&gt;

&lt;h3&gt;How Touch ID unlocks an iOS device&lt;/h3&gt;

&lt;p&gt;如果Touch ID关闭，设备锁定时，保留在安全区域中的Data Protection class Complete的密钥将被丢弃。在用户通过输入密码解锁设备之前，该类中的文件和钥匙串项目是无法访问的。&lt;/p&gt;

&lt;p&gt;当Touch ID 开启的时候，这个密钥不会在设备锁定的时候被丢弃。相反，这个密钥会被加到在安全区域内的Touch ID 子系统的密钥中。当用户尝试解锁设备时，如果Touch ID识别用户的指纹，则它会提供用于一个解密 Data Protection keys 的密钥，并且设备被解锁。这个解锁的过程需要Data Protection 和 Touch ID 子系统共同协作提供额外的保护&lt;/p&gt;

&lt;p&gt;如果设备重新启动，并且在48小时没有解锁或五次失败的Touch ID 识别尝试后，安全区域会丢弃Touch ID 解锁设备所需的密钥&lt;/p&gt;
</description>
        <pubDate>Mon, 24 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://pengxuyuan.github.io/2017/04/iOS-Security-translate/</link>
        <guid isPermaLink="true">http://pengxuyuan.github.io/2017/04/iOS-Security-translate/</guid>
        
        
      </item>
    
      <item>
        <title>NSTimer 知识点</title>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h3&gt;NSTimer 是什么&lt;/h3&gt;

&lt;p&gt;定时器 一般都是用来做一些周期性的任务&lt;/p&gt;

&lt;h3&gt;使用遇到什么问题&lt;/h3&gt;

&lt;p&gt;内存释放问题、定时器失效问题&lt;/p&gt;

&lt;h3&gt;为什么会出现这些问题&lt;/h3&gt;

&lt;h4&gt;内存释放问题&lt;/h4&gt;

&lt;p&gt;当定时器被加到run loop 生效的时候，run loop 会强引用这个定时器对象（retain），然后定时器又会强引用这个Target 对象，这样子就会导致这个定时器一直存在，这个Target 对象一直存在，导致一直释放不了&lt;/p&gt;

&lt;p&gt;单纯将NSTimer置为nil，是不能使定时器失效的，runloop 已经强引用这个timer 了，要使得定时器失效需要调用invalidate 方法&lt;/p&gt;

&lt;h4&gt;定时器失效问题  （场景：滑动TableView 的时候，定时器失效）&lt;/h4&gt;

&lt;p&gt;run loop 里面有很多模式，但是一个时间点只会处在一个模式下，在某个模式的时候，只会处理和调度这个模式下面的事件和资源，NSTimer 在用scheduledTimerWithTimeInterval 生成的时候是以默认模式加入到当前的run loop，然后模式是NSDefaultRunLoopMode，但是当TableView 滑动的时run loop 会切换到UITrackingRunLoopMode 这个模式，所以此时NSTimer 就会失效&lt;/p&gt;

&lt;p&gt;所以这里是：当run loop 切换到不是timer 加入run loop 时的模式时，这个定时器就会暂时失效&lt;/p&gt;

&lt;h4&gt;关于手动将timer 置为nil 的意义&lt;/h4&gt;

&lt;p&gt;一个变量，如果被 strong 修饰，和被 weak 修饰，是有一定的区别的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;strong&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;若一个变量被 strong 修饰 （临时变量或者非 property 变量默认 strong 修饰），则其为强指针指向，在被赋值的时候，会强引用赋值对象。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;weak&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;若一个变量被 weak 修饰，则其为弱指针指向，弱指针指向的对象，如果没有被外界进行强引用的话，会在初始化方法完成之后，将变量置空。&lt;/p&gt;

&lt;p&gt;在 timer 被 strong 和 weak 修饰时的区别&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果 timer 被 strong 修饰，那么 timer 会被 self 持有一次，加入 runloop 之后，会被 runloop 再持有一次，invalidate 只会解除 runloop 对 timer 的持有，self 还是会 持有 timer ，所以需要手动置为 nil ，解除 self 对 timer 的持有。&lt;/li&gt;
&lt;li&gt;如果 timer 被 weak 修饰，那么 timer 不会被 self 持有，只是 runloop 对 timer 有一次持有（==前提是外界没有持有该timer，如果外界持有了，需要外界也手动置空==），invalidate 解除了 runloop 对 timer 的持有之后，系统会自动将 timer 置空。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果我们用了懒加载，而且 timer 是weak 修饰，没有初始化过，在下面这种写法的时候，&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;[self.timer invalidate];
NSLog(@&amp;quot;%@&amp;quot;, _timer);
[self.timer fire];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;会发现，打印出来的 _timer 依然有值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;原因是&lt;/strong&gt;：因为 timer 并没有被初始化，我们在调用 &lt;code&gt;self.timer&lt;/code&gt; 的时候，会走get方法，因为我们在 get 方法里做了懒加载，就会走一遍初始化，但是我们又在初始化方法里，加进了 runloop ，runloop 强引用了 timer ，那么在 get 方法执行完之后，timer 并不会被销毁。但是，我们又调用了 invalidate ，这个操作只会解除 runloop 对 timer 的持有，引用计数 -1，却并不会立即将 timer 置为 nil ，所以在 调用打 log 和  &lt;code&gt;[self.timer fier]&lt;/code&gt; 的时候，get 方法并不会走初始化操作了，但是因为 timer 已经不被 runloop 强引用了，所以会失效。&lt;/p&gt;

&lt;h4&gt;关于调用invalidate 方式&lt;/h4&gt;

&lt;p&gt;在调用invalidate 是否需要用valid 来判断，懒加载的情况是需要的，因为会被置为nil，多次调用的时候会重新创建，但是直接会被invalidate，这里定位会比较麻烦
invalidate 这个是使定时器失效的，调用的时候不能dealloc 里面去调用，因为run loop 强引用了定时器，定时器又强引用了Target 对象，这个时候VC 是不会被释放的，自然不会走dealloc 方法&lt;/p&gt;

&lt;h4&gt;关于NSTimer 暂停开始&lt;/h4&gt;

&lt;p&gt;这里最优雅的方式就是写一个NSTimer 的分类，然后用fireDate 触发时间来处理&lt;/p&gt;

&lt;h3&gt;如何正确使用&lt;/h3&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;#pragma mark - Lazzy load
- (NSTimer *)timer {
    if (_timer == nil) {
        _timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(timerStep) userInfo:nil repeats:YES];
    }
    return _timer;
}

-(void)viewDidDisappear:(BOOL)animated {
    [super viewDidDisappear:animated];

    if ([self.timer isValid]) {
        [self.timer invalidate];
        self.timer = nil;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h3&gt;NSTimer 官方文档介绍&lt;/h3&gt;

&lt;h4&gt;NSTimer&lt;/h4&gt;

&lt;p&gt;你可以用NSTimer 这个类来创建定时器对象。定时器会等待一个时间间隔然后触发，向一个目标对象（Target）发送特定的消息。例如你可以创建一个定时器对象，发消息到window，告诉它隔一段时间就更新自己&lt;/p&gt;

&lt;h4&gt;Overview&lt;/h4&gt;

&lt;p&gt;定时器跟run loop 一起工作，要有效地使用定时器，你应该注意run loop 的运行机制 — 可以参阅NSRunLoop 和Threading Programming Guide 章节。特别注意，run loop 会对run loop 中的定时器维持强引用，所以你不需要在把这个定时器加入到run loop 后对它维持强引用&lt;/p&gt;

&lt;p&gt;定时器并不是一个实时机制；只有run loop 正在运行的模式是定时器加到run loop 的模式时候并且检查到这个定时器的触发时间是否过去，这样子定时器才会触发。（run loop 有很多种模式，但是一个时间点只会处在一个模式下，然后定时器加入到run loop 也是可以设置需要加入到run loop 什么模式下的）因为有存在各种输入源，run loop 是典型的循环运行管理，所以定时器间隔的有效分辨是在50-100毫秒量级。如果定时器要触发的时候出现了一个耗时的操作或者当前run loop 模式不是定时器加入时候的模式，这样子定时器是不会被触发的直到下次run loop 检查定时器。&lt;/p&gt;

&lt;p&gt;因此，定时器的触发的实际时间有可能是预定触发时间之后的相当长的一段时间，另请参考&lt;a href=&quot;#Timer%20Tolerance&quot;&gt;Timer Tolerance&lt;/a&gt;章节&lt;/p&gt;

&lt;p&gt;NSTimer 跟 Core Foundation的CFRunLoopTimerRef是“toll-free bridge”，有关toll-free bridging 信息请参考Toll-free Bridging 章节&lt;/p&gt;

&lt;h4&gt;Repeating Versus Non-Repeating Timers （重复与不重复定时器）&lt;/h4&gt;

&lt;p&gt;你在创建定时器可以指定是重复的还是不重复的。不重复定时器触发一次，然后会自动的使其自动失效，从而防止定时器再次触发。相比之下，重复定时器会在相同的run loop 上面触发并且重新排列&lt;/p&gt;

&lt;p&gt;重复定时器总是根据预定的触发时间自动安排，而不是根据实际的触发时间。例如，如果定时器计划在一个特定的时间点和之后的每5秒触发， 尽管实际的触发时间延迟了，预定的触发时间依然是在原始时间点的之后5秒，如果触发时间被延迟到它下一个（或者下几个）触发时间，则这个时间段定时器只会触发一次，然后定时器在触发后会重新排列，等待下一个预定的触发时间&lt;/p&gt;

&lt;h4&gt;Timer Tolerance 定时器误差&lt;/h4&gt;

&lt;p&gt;在iOS 7及更高版本以及macOS 10.9及更高版本中，你可以指定定时器的的误差。误差可以使得在定时器触发的时候系统更加灵活，可以提高系统的优化能力，从而提高功率节省和响应能力。 定时器会在预定的触发时间点和预定触发时间点加上误差时间之间触发(A&amp;lt;-&amp;gt;A+误差)。计时器不会在预定触发时间点之前触发。对于重复定时器，下一个触发时间是从原始时间点开始计算的，不会因为个别触发时间的误差来重新计算，避免时间点偏移。误差值默认是0，这就意味着不会加上误差，但是系统保留对某个定时器触发加上一个很小的误差的权利，这个时候不会考虑这个误差属性&lt;/p&gt;

&lt;p&gt;使用定时器，你最好了解一个合适的定时器误差值。一般的经验法则是将这个误差值最少设置成定时器间隔的10%，尽管是一个很小的误差值，也会对应用程序的耗电产生很大的积极影响。&lt;/p&gt;

&lt;h4&gt;Scheduling Timers in Run Loops&lt;/h4&gt;

&lt;p&gt;一个定时器对象只能在run loop 中注册一次，尽管它可以被加到run loop 中的不同的run loop模式中去，这里有3中方法创建定时器：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Use the scheduledTimerWithTimeInterval:invocation:repeats: or scheduledTimerWithTimeInterval:target : selector:userInfo:repeats: class method to create the timer and schedule it on the current run loop in the default mode.&lt;/p&gt;

&lt;p&gt;用这两个类方法创建定时器对象，会将这个定时器对象以默认run loop 模式（NSDefaultRunLoopMode）加到当前的run loop 中&lt;/p&gt;

&lt;p&gt;Use the timerWithTimeInterval:invocation:repeats: or timerWithTimeInterval`:targetselector:userInfo:repeats: class method to create the timer object without scheduling it on a run loop. (After creating it, you must add the timer to a run loop manually by calling the addTimer:forMode: method of the corresponding NSRunLoop object.)&lt;/p&gt;

&lt;p&gt;用这个两个类方法创建定时器对象，不会将这个对象加入到run loop 中，在创建对象后，你必须手动的将这个定时器对象加入到一个run loop 中，[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];&lt;/p&gt;

&lt;p&gt;Allocate the timer and initialize it using the initWithFireDate:interval:target :selector:userInfo:repeats: method. (After creating it, you must add the timer to a run loop manually by calling the addTimer:forMode: method of the corresponding NSRunLoop object.)
在创建对象后，你必须手动的将这个定时器对象加入到一个run loop 中，[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一旦添加到run loop中，定时器会在指定的时间间隔触发直到这个定时器失效（invalidate）。一个不重复的定时器在触发后立即使其自动失效。但是对于重复的定时器调用invalidate 才能使它失效。调用invalidate 这个方法会从当前的run loop 中移除这个定时器。因此你应该在创建这个定时器的线程调用这个invalidate 方法。会立即使这个定时器失效，使其不再影响这个run loop。在invalidate 方法返回前后，这个run loop 会移除这个定时器和对这个定时器的强引用。一旦失效，这个定时器对象不能被重用&lt;/p&gt;

&lt;p&gt;在重复定时器触发之后，它会安排下一次预定时间点的触发，这个时间点是上一次触发时间点间隔的整数倍，在公差范围内。如果调用选择器方法或者调用NSInvocation 花费的时间长于定时器的间隔时间，则这个定时器会安排在下一次再触发，也就是说，定时器不会尝试补偿在调用选择器方法或调用NSInvocation 过久导致错过启动时间。&lt;/p&gt;

&lt;h4&gt;Subclassing Notes&lt;/h4&gt;

&lt;p&gt;你不应该尝试去创建NSTimer 的子类  Crash&lt;/p&gt;

&lt;h4&gt;Symbols&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/pengxuyuan/quzhibo/master/NSTimer/B9E579FA-AF03-43E2-AB2C-31F7C742D5B7.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h4&gt;Relationships&lt;/h4&gt;

&lt;p&gt;Inherits From NSObject&lt;/p&gt;
</description>
        <pubDate>Fri, 21 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://pengxuyuan.github.io/2017/04/NSTimer/</link>
        <guid isPermaLink="true">http://pengxuyuan.github.io/2017/04/NSTimer/</guid>
        
        
      </item>
    
      <item>
        <title>Effective Objective-C 2.0 总结（一）</title>
        <description>&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;阅读书籍全名&lt;a href=&quot;http://item.jd.com/11402853.html&quot;&gt;Effective Objective-C 2.0 编写高质量iOS与OS X 代码的52个有效方法&lt;/a&gt;
最经买了本&lt;a href=&quot;http://item.jd.com/11779514.html&quot;&gt;编写高质量代码 改善Objective-C程序的61个建议&lt;/a&gt;，拿到手看了下目录感觉内容比这本52个有效方法更深点，之前只是浅度这本，具体讲什么也不是很记得了，所以打算先重新看下这本52个有效方法，然后再来拜读新入手的这本。&lt;/p&gt;

&lt;p&gt;这里准备记录下&lt;a href=&quot;http://item.jd.com/11402853.html&quot;&gt;Effective Objective-C 2.0 编写高质量iOS与OS X 代码的52个有效方法&lt;/a&gt;这本提到的知识点。&lt;/p&gt;

&lt;h3&gt;第一章 熟悉Objective-C&lt;/h3&gt;

&lt;h4&gt;第1条 了解Objective-C的起源&lt;/h4&gt;

&lt;p&gt;1.OC是C语音的超集，在C的基础上面添加了面向对象特征，并且是使用了消息结构并非函数调用。
超集的意思大概就是爸爸跟儿子，S1就是S2的超集；
&lt;img src=&quot;http://7xnp79.com1.z0.glb.clouddn.com/64380cd7912397dd663433635f82b2b7d0a2870c.png&quot; alt=&quot;&quot;&gt;
消息结构与函数调用的区别是：消息结构最终执行的代码块是由运行环境决定的，函数调用的代码块有编译器决定，在编译的时候已经确定好。&lt;/p&gt;

&lt;p&gt;2.面向过程与面向对象的区别
这个说实话我也不知道怎么解释 突然感觉很难回答这个问题&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。
面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;3.OC中的动态库与静态库
博客：&lt;br&gt;
&lt;a href=&quot;http://www.cnblogs.com/cmx-ios2014/p/3802618.html?utm_source=tuicool&amp;amp;utm_medium=referral&quot;&gt;http://www.cnblogs.com/cmx-ios2014/p/3802618.html?utm_source=tuicool&amp;amp;utm_medium=referral&lt;/a&gt;
&lt;a href=&quot;http://www.jianshu.com/p/42070c513104&quot;&gt;http://www.jianshu.com/p/42070c513104&lt;/a&gt;
&lt;a href=&quot;http://www.cnblogs.com/striveLD/p/5752010.html&quot;&gt;http://www.cnblogs.com/striveLD/p/5752010.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4.C语言中的内存模型&lt;br&gt;
&lt;a href=&quot;http://www.cnblogs.com/haore147/p/3921263.html&quot;&gt;http://www.cnblogs.com/haore147/p/3921263.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;5.内存中的堆空间(heap space) 栈(stack)&lt;br&gt;
分配在堆中的内存必须直接管理，分配在栈上用于保存变量的内存则会在栈帧弹出式自动清理。&lt;/p&gt;

&lt;p&gt;6.不能在栈上面分配OC对象&lt;/p&gt;

&lt;p&gt;7.CGRect不属于OC对象
相比于结构体，创建对象需要额外的开销，比如分配及释放内存堆，所以在操作一对非OC对象是，可以考虑用结构体来操作。&lt;/p&gt;

&lt;h4&gt;第2条 在类的头文件中尽量少引用其他头文件&lt;/h4&gt;

&lt;p&gt;1.A类的头文件中有一个B类型的属性&lt;br&gt;
引用头文件的方式有3种：#import #incudule @class关键字&lt;br&gt;
首先说明#import是由gcc编译器支持的，其实就是#incudule改良版本&lt;br&gt;
#import确保了引用的这个文件只被引进一次，而#incudule就会出现死循环引用，导致程序报错；&lt;br&gt;
@class关键字“向前声明”告诉你有这个类，具体定义不清楚，这样子可以解决引用无法识别该对象的问题，也解决了循环引用的问题&lt;br&gt;
#import #incudule 引进类来，会拿到这个类的头文件的信息了，这里违反了最少原则，所以一般在.h头文件中尽量少用；&lt;br&gt;
使用@class可以减少.h中对其他类的依赖、减少链接到其他类所需要的时间，从而降低编译时间；  &lt;/p&gt;

&lt;p&gt;一般来说在.h中，首选@class 然后在迫不得已的时候才用#import(继承，实现协议)&lt;br&gt;
对于协议来说 可以使用类扩展在.m中申明一个匿名类别来声明，只有在子类需要统一实现这个协议的时候才会放在.h中，暂时没有了解到其他情况得非在.h中#import协议。  &lt;/p&gt;

&lt;p&gt;2.两个类互相引用的问题 A类中有B类的属性 B类中也有A类的属性&lt;br&gt;
使用#incudule这样子会报错，但是使用#import的话只能保证一个类被编译到了，也是用问题的，在这里只能用@class解决这个循环引用的问题。  &lt;/p&gt;

&lt;p&gt;&lt;del&gt;3.在实现文件中声明此类实现了该委托协议，并把这段代码放在“class-continuation”分类中&lt;/del&gt;&lt;/p&gt;

&lt;h4&gt;第3条 多使用字面量语法，少用与之等价的方法&lt;/h4&gt;

&lt;p&gt;1.好处缩减代码长度，更加易读&lt;/p&gt;

&lt;p&gt;2.对于字面量数组/字典来说，对象中有nil会抛出异常&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;NSArray *array = @[@&amp;quot;&amp;quot;,@&amp;quot;&amp;quot;,@&amp;quot;&amp;quot;];&lt;/p&gt;

&lt;p&gt;NSDictionary *dictionary = @{key:value}；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;3.糖衣语法(语法糖)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;糖衣语法，又叫‘语法糖’、‘语法盐’等等，是由英国计算机科学家彼得·约翰·兰达（Peter J.Landin）发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;额，就是简单粗暴，减少出错；&lt;/p&gt;

&lt;p&gt;&lt;del&gt;4.字面量语法 非字面量语法&lt;/del&gt;&lt;/p&gt;

&lt;h4&gt;第4条 多用类型常量，少用#define预处理指令&lt;/h4&gt;

&lt;p&gt;1.#define预处理指令
#define kAnimationTime 3&lt;br&gt;
在程序代码中多次使用同一个变量，可以用#define预处理指令来抽取，这样子可以达到第一层的抽取，在一般情况下面我们可以满足需求，利用define它会将kAnimationTime直接替换成3；所以这里如果定义在.h文件中，在其他引用了这个头文件的类中的kAnimationTime也会被替换，而且#define预处理指令是没有类型的，替换掉了也不清楚，可以在引用的地方修改定义好的值，有一定的风险，万一实在想用，记得注意命名问题和定义的位置。  &lt;/p&gt;

&lt;p&gt;2.定义常量跟#define预处理指令的区别
static const CGFloat kMargin = 10.0f；&lt;br&gt;
可以明确的定义清楚类型，防止使用代码修改值，这样子在使用的过程减少出错。&lt;br&gt;
定义名字的常用规则：需要限定在某编译单元(即本类中)则在前面添加k；&lt;br&gt;
需要在其他类可见，一般是用此类的类名做前缀；&lt;br&gt;
使用static修饰，是将该变量仅仅定义在该变量的编译单元中，如果不使用static修饰,编译器会为这个变量创建一个&amp;quot;外部符号&amp;quot;,此时其他类也声明了同名变量就会报错了。&lt;/p&gt;

&lt;p&gt;3.全局常量，需要添加到“全局符号表中”&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;extern NSString *const PXYNotification;  &lt;/p&gt;

&lt;p&gt;NSString *const PXYNotification = @PXYNotification&amp;quot;&amp;quot;;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;del&gt;####第5条 用枚举表示状态、选项、状态码&lt;/del&gt;
&lt;del&gt;1.定义枚举的几种方式&lt;/del&gt;
&lt;del&gt;2.按位与操作符&lt;/del&gt;
&lt;del&gt;3.NS_ENUM与NS_OPTIONS宏的区别&lt;/del&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 28 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://pengxuyuan.github.io/2016/07/Effective-Objective-C-2.0-zongjie-one/</link>
        <guid isPermaLink="true">http://pengxuyuan.github.io/2016/07/Effective-Objective-C-2.0-zongjie-one/</guid>
        
        
      </item>
    
      <item>
        <title>iOS单例模式</title>
        <description>&lt;p&gt;单例 保证一个对象只实例化一次 全局使用的都是同一个对象&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一是某个类只能有一个实例；&lt;/li&gt;
&lt;li&gt;二是它必须自行创建这个实例；&lt;/li&gt;
&lt;li&gt;三是它必须自行向整个系统提供这个实例。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一种写法：
&lt;pre&gt; +(instancetype)shareInstance{&lt;br&gt;
static PXYGuidePageHelper *instance;&lt;br&gt;
        @synchronized(self) {&lt;br&gt;
            if (instance == nil) {&lt;br&gt;
                instance = [PXYGuidePageHelper new];&lt;br&gt;
            }&lt;br&gt;
        }&lt;br&gt;
    return instance;&lt;br&gt;
}&lt;br&gt;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;第二种写法：
&lt;pre&gt; +(instancetype)shareInstance{
    static dispatch_once_t onceToken;
    static PXYGuidePageHelper *instance;
    dispatch_once(&amp;amp;onceToken, &lt;sup&gt;{&lt;/sup&gt;
        instance = [PXYGuidePageHelper new];
    });
    return instance;
}
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;首先说下第一种写法：
单例实例是全局使用的，因此要要定义成全局变量 用static修饰 static介绍
@synchronized这个指令是解决多个线程同时执行同一个代码块 ，@synchronized相当于给这个代码块加锁（防止死锁）
这里判断当前对象时候存在，不存在创建，存在则返回该对象。&lt;/p&gt;

&lt;p&gt;第二种写法：
dispatch_once这个就是保证只执行一次 所以这里确保 该实例只创建一次&lt;/p&gt;

&lt;p&gt;两者区别：
第一种在每次执行shareInstance方法是都会加一次锁，然后在代码块里面判断 if (instance == nil) 这个来决定是否实例化，这里每次都会有开销。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;“实际上，如果你去看这个函数所在的头文件，你会发现目前它的实现其实是一个宏，进行了内联的初始化测试，这意味着通常情况下，你不用付出函数调用的负载代价，并且会有更少的同步控制负载。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这样子分析的GCD创建单例更加优雅点。&lt;/p&gt;

&lt;p&gt;－－－－&lt;br&gt;
第一种相当于是 懒汉式单例类 双检锁写法&lt;/p&gt;

&lt;p&gt;对于第一种的每次都要加锁的写法，可以使用双检锁写法来提高效率。
&lt;pre&gt;+(instancetype)shareInstance{
    static PXYGuidePageHelper *instance;
    if (instance == nil) {
        @synchronized(self) {
            if (instance == nil) {
                instance = [PXYGuidePageHelper new];
            }
        }
    }
    return instance;
}&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;这样子就能保证只有在第一次进行加锁开销。&lt;/p&gt;

&lt;p&gt;还有一种 饿汉式单例
是在程序一启动就实例化 +(void)load函数里面实现，然后在allocWithZone进行加锁判空操作，这样子无论你是否用特定的方法获取实例，都会返回同一个对象。&lt;/p&gt;

&lt;p&gt;以上&lt;/p&gt;
</description>
        <pubDate>Thu, 28 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://pengxuyuan.github.io/2016/07/iOS_SigleCase/</link>
        <guid isPermaLink="true">http://pengxuyuan.github.io/2016/07/iOS_SigleCase/</guid>
        
        
      </item>
    
      <item>
        <title>关于团队开发的编码规范</title>
        <description>&lt;p&gt;以下是均是个人看法，不喜勿喷，欢迎大家一起多多交流，共同进步。&lt;/p&gt;

&lt;p&gt;对于编码，每个人都有自己的习惯 ，但是我觉得要开发出优质代码的话有些规范还是要统一，毕竟你不是一个人做开发，你要考虑到团队协作以及后续人员维护你的项目，你想一下，让你维护一个别人的项目，上来就是ViewController几千行，所有页面逻辑全部在控制器里面，各种不能见名思义的变量属性，瞬间有种想死的感觉有木有😂😂😂所以吧，还是不要任性开发。&lt;/p&gt;

&lt;p&gt;说是对于团队开发的编码规范，其实在个人独立开发的时候也需要注意编码的问题，网上面有很多大神写的关于编码的blog，我就不复述了...&lt;/p&gt;

&lt;p&gt;这里我就写写最近在团队发开种遇到的问题吧，写的不全，后期遇到的其他问题都会贴上来的，一是提醒自己在编码过程中要规范，二是让大家看看我有什么地方理解错了，及时改正，三是，额，三是我写动手写点东西了，好久没写了....&lt;/p&gt;

&lt;p&gt;好了，入正题吧 不然又......&lt;/p&gt;

&lt;h5&gt;1.你要了解点MVC 最少你要知道我们还有View 跟 Model吧&lt;/h5&gt;

&lt;p&gt;哥哥，真的不要给我控制器里面写个几千行，我实在是维护不了，不要说维护了，估计在看懂你的逻辑之前我都已经挂了...&lt;/p&gt;

&lt;p&gt;现在项目开发中，最常用的就是MVC了，然后就是MVVM（我就只会这两个）有这两个开发一般般的项目我觉得够用了。控制器是拿来连接View跟Model的 扮演个协调者的角色 并不是要你把所有的逻辑写在里面。&lt;/p&gt;

&lt;h5&gt;2.我们先谈谈ViewController里面的一些东西&lt;/h5&gt;

&lt;p&gt;首先，不要把所有的属性变量放在.h文件里面。.h文件是暴露出去的，所以越简洁越好，坚持最少原则，用最少最简单的方式完成功能，你放在.h别人用的时候就可以随意操作你的暴露出去的东西了额，还有，我没搞懂为什么在.m文件里面实现的代理，声明要放在.h 比如说这个不要放在.h吧 实在是不好看，也没什么用。&lt;/p&gt;

&lt;p&gt;还有如果想更好点的话，在.h尽可能的用@class 这样子编译的压力小点 逼格也高点&lt;/p&gt;

&lt;p&gt;对于声明变量属性的话，到底是下面&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;｛
 UITableview  *tableview；
｝&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;还是&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;@property (nonatomic,strong) UITableView *tableview;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;哪个好呢，其实都还好，看个人，我比较喜欢下面那种，可以自动生成get set方法 用懒加载的时候也很是方便啊&lt;/p&gt;

&lt;p&gt;然后在使用的时候，也要注意下 不要一时用 _tableview 一时用self.tableview 一开始我是分别用的，后来看书看到，_tableview 跟self-&amp;gt;tableview 是直接访问地址的，self.tableview是通过消息机制调用get方法，所以呢，_tableview获取的比self. tableview快，所以折中的方法是，在内部读取数据时候尽量用_tableView，设置属性值时候，用self.tableview，这样子你可以通过重写set方法 更加可控 可调试点。&lt;/p&gt;

&lt;h5&gt;关于命名&lt;/h5&gt;

&lt;p&gt;额，命名这个东西老生常谈了，个人坚持的是，宁愿长也不要难认识。&lt;/p&gt;

&lt;h5&gt;函数摆放&lt;/h5&gt;

&lt;p&gt;个人有强迫症，所以比较会注意。&lt;/p&gt;

&lt;p&gt;比如生命周期函数写在一块 懒加载一块 网络请求一块 代理一块 事件一块&lt;/p&gt;

&lt;p&gt;用个#pragma mark - - 瞬间整个世界都有序了 有木有！！！&lt;/p&gt;

&lt;h5&gt;关于注释&lt;/h5&gt;

&lt;p&gt;说到这里，再说下关于注释这东西。通常说法是：程序员最讨厌别人不写注释和自己写注释。&lt;/p&gt;

&lt;p&gt;其实个人我是坚持代码即注释，就是比较讨厌注释的，觉得好的代码不需要注释。&lt;/p&gt;

&lt;p&gt;我总感觉注释很脏啊- -  总感觉多了点什么。（个人强迫症原因....）&lt;/p&gt;

&lt;p&gt;吐槽下，接手的项目全部是注释，关键是注释都没什么用啊.....&lt;/p&gt;

&lt;p&gt;生命周期函数全部写一次注释，这些不写 新生都知道是干嘛的啊- -&lt;/p&gt;

&lt;p&gt;关键是.m文件你的注释为什么要写成这样子呢？&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;/**
*
*初始化方法
*@return self
*/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;每个生命周期都是这样子，是真的烦，反正看到的我都删除了。&lt;/p&gt;

&lt;h5&gt;3.关于View&lt;/h5&gt;

&lt;p&gt;个人观点：凡事复杂点的组件（你在屏幕上看到的东西） 都自己写个view出来 不要在ViewController里面写你View里面的布局逻辑，这样子控制器本来不胖的都被你搞胖了😂😂😂&lt;/p&gt;

&lt;p&gt;额，还有，发现很多人虽然写了View 但是 但是 他把View的控件属性全部写在.h里面 然后在ViewController里面直接赋值，这样子还真没搞懂你的View到底是干嘛的 也不能只写布局啊。自己的东西自己管啊，View.h 暴露个Model，ViewController传个Model就好了啊 再不济你传个字典也比在ViewController直接赋值的好啊。&lt;/p&gt;

&lt;p&gt;最后就是：自己的事情自己做&lt;/p&gt;

&lt;p&gt;而还有，不要滥用自定义View 我最近看到一种写法是 View嵌入View然后再嵌入View再嵌入View....太恶心了&lt;/p&gt;

&lt;p&gt;更甚的是，全部写在.h中 设置属性的就是在控制器self.view.view.view.text 然后增加事件就是 self.view.view.view addTag&lt;/p&gt;

&lt;p&gt;看到这个我心中无数只草泥马啊。。。&lt;/p&gt;

&lt;p&gt;善用代理跟block 这样子代码好看还解藕了，多好。&lt;/p&gt;

&lt;p&gt;最近还看到一种用协议来创建自定义View的 是真的厉害 高内聚 代码一下子就可以看懂了 而且逼格一下子就上去了。&lt;/p&gt;

&lt;p&gt;网址：&lt;a href=&quot;http://reviewcode.cn/article.html?reviewId=5&quot;&gt;自定义UI控件&lt;/a&gt;&lt;/p&gt;

&lt;h5&gt;其他&lt;/h5&gt;

&lt;p&gt;额 说到逼格  最近学到 定义常量少用&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;#define&lt;/p&gt;

&lt;p&gt;用static const CGFloat kBorderMargin = 15;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这样子会比较好，可以预先知道类型，减少出错的机会。&lt;/p&gt;

&lt;h5&gt;4.现在的文件命名还不错，都是峰驼式的。&lt;/h5&gt;

&lt;h5&gt;5.封装思想，重用组件。&lt;/h5&gt;

&lt;p&gt;编码的时候做个懒人。&lt;/p&gt;

&lt;p&gt;不要重复的写一样的代码，还不好改。具体的，也不好写，思想大概就是多处用到的一样的东西，抽出来，不要copy代码。&lt;/p&gt;

&lt;h5&gt;The End&lt;/h5&gt;

&lt;p&gt;这篇文章就是拿来练习下markdown的，刚学。&lt;/p&gt;
</description>
        <pubDate>Mon, 13 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://pengxuyuan.github.io/2016/06/CodingStandardsForTeamDevelopment/</link>
        <guid isPermaLink="true">http://pengxuyuan.github.io/2016/06/CodingStandardsForTeamDevelopment/</guid>
        
        
      </item>
    
  </channel>
</rss>
